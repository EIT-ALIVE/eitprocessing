:py:mod:`eitprocessing.binreader.sequence`
==========================================

.. py:module:: eitprocessing.binreader.sequence

.. autoapi-nested-parse::

   Copyright 2023 Netherlands eScience Center and Erasmus University Medical Center.
   Licensed under the Apache License, version 2.0. See LICENSE for details.

   This file contains methods related to parts of electrical impedance tomographs
   as they are read.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   eitprocessing.binreader.sequence.Vendor
   eitprocessing.binreader.sequence.Sequence
   eitprocessing.binreader.sequence.DraegerSequence
   eitprocessing.binreader.sequence.TimpelSequence




.. py:class:: Vendor

   Bases: :py:obj:`strenum.LowercaseStrEnum`

   Enum indicating the vendor (manufacturer) of the EIT device with which the data was gathered.

   .. py:attribute:: DRAEGER

      

   .. py:attribute:: TIMPEL

      

   .. py:attribute:: SENTEC

      

   .. py:attribute:: DRAGER

      

   .. py:attribute:: DRÃ„GER

      


.. py:class:: Sequence

   Sequence of timepoints containing EIT and/or waveform data.

   A Sequence is a representation of a continuous set of data points, either EIT frames,
   waveform data, or both. A Sequence can consist of an entire measurement, a section of a
   measurement, a single breath, or even a portion of a breath.
   A sequence can be split up into separate sections of a measurement or multiple (similar)
   Sequence objects can be merged together to form a single Sequence.

   EIT data is contained within Framesets. A Frameset shares the time axis with a Sequence.

   :param path: path(s) to data file.
   :type path: Path | str | list[Path | str]
   :param vendor: vendor indicating the device used.
   :type vendor: Vendor | str
   :param label: description of object for human interpretation.
                 Defaults to "Sequence_<unique_id>".
   :type label: str
   :param time: list of time label for each data point (can be
                true time or relative time)
   :type time: NDArray[float]
   :param max_frames: number of frames in sequence
   :type max_frames: int
   :param framerate: framerate at which the data was recorded.
                     Defaults to 20 if vendor == DRAEGER
                     Defaults to 50 if vendor == TIMPEL
   :type framerate: int, optional
   :param framesets: dictionary of framesets
   :type framesets: dict[str, Frameset]
   :param events: list of Event objects in data
   :type events: list[Event]
   :param timing_errors: list of TimingError objects in data
   :type timing_errors: list[TimingError]
   :param phases: list of PhaseIndicator objects in data
   :type phases: list[PhaseIndicator]

   .. py:attribute:: path
      :type: Path | str | list[Path | str] | None

      

   .. py:attribute:: vendor
      :type: Vendor | str | None

      

   .. py:attribute:: label
      :type: str | None

      

   .. py:attribute:: time
      :type: NDArray | None

      

   .. py:attribute:: nframes
      :type: int | None

      

   .. py:attribute:: framerate
      :type: int | None

      

   .. py:attribute:: framesets
      :type: dict[str, eitprocessing.binreader.frameset.Frameset]

      

   .. py:attribute:: events
      :type: list[eitprocessing.binreader.event.Event]

      

   .. py:attribute:: timing_errors
      :type: list[eitprocessing.binreader.timing_error.TimingError]

      

   .. py:attribute:: phases
      :type: list[eitprocessing.binreader.phases.PhaseIndicator]

      

   .. py:method:: __post_init__()


   .. py:method:: __len__() -> int


   .. py:method:: __eq__(other) -> bool

      Return self==value.


   .. py:method:: _set_vendor_class()

      Re-assign Sequence class to child class for selected Vendor.

      :raises NotImplementedError: if the child class for the selected vendor
          has not yet been implemented.
      :raises TypeError: if the `vendor` argument does not correspond to the expected
          vendor for `type(self)`.


   .. py:method:: check_equivalence(a: Sequence, b: Sequence)
      :staticmethod:

      Checks whether content of two Sequence objects is equivalent.


   .. py:method:: __add__(other: Sequence) -> Sequence


   .. py:method:: merge(a: Sequence, b: Sequence, label: str | None = None) -> Sequence
      :classmethod:

      Create a merge of two Sequence objects.


   .. py:method:: from_path(path: Path | str | list[Path | str], vendor: Vendor | str, label: str | None = None, framerate: int | None = None, first_frame: int = 0, max_frames: int | None = None) -> Sequence
      :classmethod:

      Load sequence from path(s)

      :param path: path(s) to data file.
      :type path: Path | str | list[Path | str]
      :param vendor: vendor indicating the device used.
      :type vendor: Vendor | str
      :param label: description of object for human interpretation.
                    Defaults to "Sequence_<unique_id>".
      :type label: str
      :param framerate: framerate at which the data was recorded.
                        Default for Draeger: 20
                        Default for Timpel: 50
      :type framerate: int, optional
      :param first_frame: index of first time point of sequence
                          (i.e. NOT the timestamp).
                          Defaults to 0.
      :type first_frame: int, optional
      :param max_frames: maximum number of frames to load.
                         The actual number of frames can be lower than this if this
                         would surpass the final frame.
      :type max_frames: int, optional

      :raises NotImplementedError: is raised when there is no loading method for
      :raises the given vendor.:

      :returns: a sequence containing the loaded data from all files in path
      :rtype: Sequence


   .. py:method:: _from_path(path: Path | str | list[Path | str], label: str | None = None, framerate: int | None = None, first_frame: int = 0, max_frames: int | None = None)
      :classmethod:


   .. py:method:: _load_file(path: Path | str, label: str | None = None, framerate: int | None = None, first_frame: int = 0, max_frames: int | None = None) -> Sequence
      :classmethod:

      Method used by `from_path` that initiates the object and calls
      child method for loading the data.

      See `from_path` method for arguments.


   .. py:method:: _load_data(first_frame: int | None)
      :abstractmethod:

      Needs to be implemented in child class.


   .. py:method:: select_by_index(indices: slice, label: str | None = None)


   .. py:method:: __getitem__(indices: slice)


   .. py:method:: select_by_time(start: float | int | None = None, end: float | int | None = None, start_inclusive: bool = True, end_inclusive: bool = False, label: str | None = None) -> Sequence

      Select subset of sequence by the `Sequence.time` information (i.e.
      based on the time stamp).

      :param start: starting time point.
                    Defaults to None.
      :type start: float | int | None, optional
      :param end: ending time point.
                  Defaults to None.
      :type end: float | int | None, optional
      :param start_inclusive: include starting timepoint if
                              `start` is present in `Sequence.time`.
                              Defaults to True.
      :type start_inclusive: bool, optional
      :param end_inclusive: include ending timepoint if
                            `end` is present in `Sequence.time`.
                            Defaults to False.
      :type end_inclusive: bool, optional

      :raises ValueError: if the Sequence.time is not sorted

      :returns: a slice of `self` based on time information given.
      :rtype: Sequence


   .. py:method:: deepcopy(label: str | None = None, relabel: bool | None = True) -> Sequence

      Create a deep copy of `Sequence` object.

      :param label: Create a new `label` for the copy.
                    Defaults to None, which will trigger behavior described for relabel (below)
      :type label: str
      :param relabel: If `True` (default), the label of self is re-used for the copy,
                      otherwise the following label is assigned f"Deepcopy of {self.label}".
                      Note that this setting is ignored if a label is given.
      :type relabel: bool

      :returns: a deep copy of self
      :rtype: Sequence



.. py:class:: DraegerSequence

   Bases: :py:obj:`Sequence`

   Sequence object for DRAEGER data.

   .. py:attribute:: vendor
      :type: Literal[Vendor]

      

   .. py:attribute:: framerate
      :type: float
      :value: 20

      

   .. py:method:: from_path(*args, **kwargs) -> DraegerSequence
      :classmethod:

      Load sequence from path(s)

      :param path: path(s) to data file.
      :type path: Path | str | list[Path | str]
      :param vendor: vendor indicating the device used.
      :type vendor: Vendor | str
      :param label: description of object for human interpretation.
                    Defaults to "Sequence_<unique_id>".
      :type label: str
      :param framerate: framerate at which the data was recorded.
                        Default for Draeger: 20
                        Default for Timpel: 50
      :type framerate: int, optional
      :param first_frame: index of first time point of sequence
                          (i.e. NOT the timestamp).
                          Defaults to 0.
      :type first_frame: int, optional
      :param max_frames: maximum number of frames to load.
                         The actual number of frames can be lower than this if this
                         would surpass the final frame.
      :type max_frames: int, optional

      :raises NotImplementedError: is raised when there is no loading method for
      :raises the given vendor.:

      :returns: a sequence containing the loaded data from all files in path
      :rtype: Sequence


   .. py:method:: _load_data(first_frame: int)

      Load data for DRAEGER files.


   .. py:method:: _read_frame(reader: eitprocessing.binreader.reader.Reader, index: int, pixel_values: numpy.typing.NDArray, previous_marker: int | None)

      Read frame by frame data from DRAEGER files.


   .. py:method:: reshape_frame(frame)
      :staticmethod:

      Convert linear array into 2D (32x32) image-like array.



.. py:class:: TimpelSequence

   Bases: :py:obj:`Sequence`

   Sequence object for TIMPEL data.

   .. py:attribute:: vendor
      :type: Vendor

      

   .. py:attribute:: framerate
      :type: float
      :value: 50

      

   .. py:method:: from_path(*args, **kwargs) -> TimpelSequence
      :classmethod:

      Load sequence from path(s)

      :param path: path(s) to data file.
      :type path: Path | str | list[Path | str]
      :param vendor: vendor indicating the device used.
      :type vendor: Vendor | str
      :param label: description of object for human interpretation.
                    Defaults to "Sequence_<unique_id>".
      :type label: str
      :param framerate: framerate at which the data was recorded.
                        Default for Draeger: 20
                        Default for Timpel: 50
      :type framerate: int, optional
      :param first_frame: index of first time point of sequence
                          (i.e. NOT the timestamp).
                          Defaults to 0.
      :type first_frame: int, optional
      :param max_frames: maximum number of frames to load.
                         The actual number of frames can be lower than this if this
                         would surpass the final frame.
      :type max_frames: int, optional

      :raises NotImplementedError: is raised when there is no loading method for
      :raises the given vendor.:

      :returns: a sequence containing the loaded data from all files in path
      :rtype: Sequence


   .. py:method:: _load_data(first_frame: int)

      Load data for TIMPEL files.



