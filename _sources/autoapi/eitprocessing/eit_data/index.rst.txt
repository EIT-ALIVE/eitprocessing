:py:mod:`eitprocessing.eit_data`
================================

.. py:module:: eitprocessing.eit_data


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   draeger/index.rst
   event/index.rst
   phases/index.rst
   sentec/index.rst
   timpel/index.rst
   vendor/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   eitprocessing.eit_data.Vendor
   eitprocessing.eit_data.Equivalence
   eitprocessing.eit_data.SelectByTime
   eitprocessing.eit_data.EITData
   eitprocessing.eit_data.EITData_




Attributes
~~~~~~~~~~

.. autoapisummary::

   eitprocessing.eit_data.T


.. py:class:: Vendor


   Bases: :py:obj:`strenum.LowercaseStrEnum`

   Enum indicating the vendor (manufacturer) of the source EIT device.

   .. py:attribute:: DRAEGER

      

   .. py:attribute:: TIMPEL

      

   .. py:attribute:: SENTEC

      

   .. py:attribute:: DRAGER

      

   .. py:attribute:: DRÃ„GER

      


.. py:class:: Equivalence


   Mixin class that adds an equality and equivalence check.

   .. py:method:: __eq__(other: typing_extensions.Self)

      Return self==value.


   .. py:method:: _array_safe_eq(a: Any, b: Any) -> bool
      :staticmethod:

      Check if a and b are equal, even if they are numpy arrays containing nans.


   .. py:method:: isequivalent(other: typing_extensions.Self, raise_: bool = False) -> bool

      Test whether the data structure between two objects are equivalent.

      Equivalence, in this case means that objects are compatible e.g. to be
      merged. Data content can vary, but e.g. the category of data (e.g.
      airway pressure, flow, tidal volume) and unit, etc., must match.


      :param other: object that will be compared to self.
      :param raise_: sets this method's behavior in case of non-equivalence. If
                     True, an `EquivalenceError` is raised, otherwise `False` is
                     returned.

      :raises EquivalenceError: if `raise_ == True` and the objects are not
      :raises equivalent.:

      :returns: bool describing result of equivalence comparison.



.. py:class:: SelectByTime


   Bases: :py:obj:`SelectByIndex`

   Adds methods for slicing by time rather than index.

   .. py:property:: t
      :type: TimeIndexer

      Time Indexer property.

   .. py:attribute:: time
      :type: numpy.typing.NDArray

      

   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, start_inclusive: bool = True, end_inclusive: bool = False, label: str | None = None) -> typing_extensions.Self

      Get a slice from start to end time stamps.

      Given a start and end time stamp (i.e. its value, not its index),
      return a slice of the original object, which must contain a time axis.

      :param start_time: first time point to include. Defaults to first frame of sequence.
      :param end_time: last time point. Defaults to last frame of sequence.
      :param start_inclusive (default: `True`), end_inclusive (default `False`):
                                       these arguments control the behavior if the given time stamp
                                       does not match exactly with an existing time stamp of the input.
                                       if `True`: the given time stamp will be inside the sliced object.
                                       if `False`: the given time stamp will be outside the sliced object.
      :param label: Description. Defaults to None, which will create a label based
                    on the original object label and the frames by which it is sliced.

      :raises TypeError: if `self` does not contain a `time` attribute.
      :raises ValueError: if time stamps are not sorted.

      :returns: Slice of self.



.. py:data:: T

   

.. py:class:: EITData


   Bases: :py:obj:`eitprocessing.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.mixins.equality.Equivalence`, :py:obj:`abc.ABC`

   Container for EIT data.

   This class holds the pixel impedance from an EIT measurement, as well as metadata describing the measurement. The
   class is meant to hold data from (part of) a singular continuous measurement.

   This class can't be initialized directly. Instead, use `EITData.from_path(...)` to load data from disk.
   Currently, loading data from three vendors is supported. You can either pass the vendor when using
   `EITData.from_path(..., vendor="timpel")`, or use one of the available subclasses of EITData:
   `SentecEITData.from_path(...)`.

   Several convenience methods are supplied for calculating global impedance, calculating or removing baselines, etc.

   .. py:property:: global_baseline
      :type: numpy.ndarray

      Return the global baseline, i.e. the minimum pixel impedance across all pixels.

   .. py:property:: pixel_impedance_global_offset
      :type: numpy.ndarray

      Return the pixel impedance with the global baseline removed.

      In the resulting array the minimum impedance across all pixels is set to 0.

   .. py:property:: pixel_baseline
      :type: numpy.ndarray

      Return the lowest value in each individual pixel over time.

   .. py:property:: pixel_impedance_individual_offset
      :type: numpy.ndarray

      Return the pixel impedance with the baseline of each individual pixel removed.

      Each pixel in the resulting array has a minimum value of 0.

   .. py:property:: global_impedance
      :type: numpy.ndarray

      Return the global impedance, i.e. the sum of all pixels at each frame.

   .. py:attribute:: path
      :type: pathlib.Path | list[pathlib.Path]

      

   .. py:attribute:: nframes
      :type: int

      

   .. py:attribute:: time
      :type: numpy.typing.NDArray

      

   .. py:attribute:: framerate
      :type: float

      

   .. py:attribute:: vendor
      :type: vendor.Vendor

      

   .. py:attribute:: phases
      :type: list

      

   .. py:attribute:: events
      :type: list

      

   .. py:attribute:: label
      :type: str | None

      

   .. py:attribute:: pixel_impedance
      :type: numpy.typing.NDArray

      

   .. py:method:: __post_init__()


   .. py:method:: from_path(path: str | pathlib.Path | list[str | pathlib.Path], vendor: vendor.Vendor | str, framerate: float | None = None, first_frame: int = 0, max_frames: int | None = None, return_non_eit_data: bool = False) -> eitprocessing.data_collection.DataCollection | tuple[eitprocessing.data_collection.DataCollection, eitprocessing.data_collection.DataCollection, eitprocessing.data_collection.DataCollection]
      :classmethod:

      Load sequence from path(s).

      :param path: relative or absolute path(s) to data file.
      :param vendor: vendor indicating the device used.
      :param label: description of object for human interpretation.
                    Defaults to "Sequence_<unique_id>".
      :param framerate: framerate at which the data was recorded.
                        Default for Draeger: 20
                        Default for Timpel: 50
                        Default for Sentec: 50.2
      :param first_frame: index of first frame to load.
                          Defaults to 0.
      :param max_frames: maximum number of frames to load.
                         The actual number of frames can be lower than this if this
                         would surpass the final frame.
      :param return_non_eit_data: whether to load available continuous and sparse data.

      :raises NotImplementedError: is raised when there is no loading method for
      :raises the given vendor.:

      :returns: container for the loaded data and metadata from all files in path.
      :rtype: EITData


   .. py:method:: _from_path(path: pathlib.Path, framerate: float | None = None, first_frame: int | None = None, max_frames: int | None = None, return_non_eit_data: bool = False) -> eitprocessing.data_collection.DataCollection | tuple[eitprocessing.data_collection.DataCollection, eitprocessing.data_collection.DataCollection, eitprocessing.data_collection.DataCollection]
      :classmethod:
      :abstractmethod:


   .. py:method:: _ensure_path_list(path: str | pathlib.Path | list[str | pathlib.Path]) -> list[pathlib.Path]
      :staticmethod:


   .. py:method:: _get_vendor_class(vendor: vendor.Vendor) -> type[EITData_]
      :staticmethod:


   .. py:method:: _check_first_frame(first_frame: int | None) -> int
      :staticmethod:


   .. py:method:: _ensure_vendor(vendor: vendor.Vendor | str) -> vendor.Vendor
      :staticmethod:

      Check whether vendor exists, and assure it's a Vendor object.


   .. py:method:: concatenate(other: T, label: str | None = None) -> T


   .. py:method:: _sliced_copy(start_index: int, end_index: int, label: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.


   .. py:method:: __len__()



.. py:class:: EITData_


   Bases: :py:obj:`EITData`

   Container for EIT data.

   This class holds the pixel impedance from an EIT measurement, as well as metadata describing the measurement. The
   class is meant to hold data from (part of) a singular continuous measurement.

   This class can't be initialized directly. Instead, use `EITData.from_path(...)` to load data from disk.
   Currently, loading data from three vendors is supported. You can either pass the vendor when using
   `EITData.from_path(..., vendor="timpel")`, or use one of the available subclasses of EITData:
   `SentecEITData.from_path(...)`.

   Several convenience methods are supplied for calculating global impedance, calculating or removing baselines, etc.

   .. py:attribute:: vendor
      :type: vendor.Vendor

      

   .. py:method:: __add__(other: T) -> T


   .. py:method:: from_path(path: str | pathlib.Path | list[str | pathlib.Path], framerate: float | None = None, first_frame: int = 0, max_frames: int | None = None, return_non_eit_data: bool = False) -> eitprocessing.data_collection.DataCollection | tuple[eitprocessing.data_collection.DataCollection, eitprocessing.data_collection.DataCollection, eitprocessing.data_collection.DataCollection]
      :classmethod:

      Load sequence from path(s).

      :param path: relative or absolute path(s) to data file.
      :param vendor: vendor indicating the device used.
      :param label: description of object for human interpretation.
                    Defaults to "Sequence_<unique_id>".
      :param framerate: framerate at which the data was recorded.
                        Default for Draeger: 20
                        Default for Timpel: 50
                        Default for Sentec: 50.2
      :param first_frame: index of first frame to load.
                          Defaults to 0.
      :param max_frames: maximum number of frames to load.
                         The actual number of frames can be lower than this if this
                         would surpass the final frame.
      :param return_non_eit_data: whether to load available continuous and sparse data.

      :raises NotImplementedError: is raised when there is no loading method for
      :raises the given vendor.:

      :returns: container for the loaded data and metadata from all files in path.
      :rtype: EITData



.. py:exception:: UnknownVendorError


   Bases: :py:obj:`ValueError`

   Raised when an unknown vendor is provided when trying to load data.


