:py:mod:`eitprocessing.continuous_data`
=======================================

.. py:module:: eitprocessing.continuous_data


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   continuous_data_collection/index.rst
   continuous_data_variant/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   eitprocessing.continuous_data.ContinuousDataVariant
   eitprocessing.continuous_data.Equivalence
   eitprocessing.continuous_data.VariantCollection
   eitprocessing.continuous_data.ContinuousData




.. py:class:: ContinuousDataVariant


   Bases: :py:obj:`eitprocessing.variants.Variant`

   Contains a single variant of a dataset.

   A variant of a dataset is defined as either the raw data, or an edited
   version of that raw data. For example, EIT data can contain a "raw"
   versions and a "filtered" version. Both variants share the same time axis.

   The actual data of a variant is contained in a variable that must be set by
   a subclass inheriting from this class.

   Attributes:
   - label (str): a short descriptor for the variant, that is used to access
     the variant
   - description (str): a longer description of the variant
   - params (dict): contains information on how to reproduce the variant, e.g.
     which filters and filters settigs were used

   .. py:attribute:: values
      :type: numpy.typing.NDArray

      

   .. py:method:: __len__() -> int


   .. py:method:: concatenate(a: typing_extensions.Self, b: typing_extensions.Self) -> typing_extensions.Self
      :classmethod:

      Concatenates two variants.

      Concatenating two variants results in a single variant with the
      combined length of both variants.

      To merge more than two variants, use
      `functools.reduce(Variant.concatenate, list_of_variants)`.

      Args:
      - a (Variant)
      - b (Variant)

      Raises:
      - EquivalenceError if a and b are not equivalent and can't be merged



.. py:class:: Equivalence


   Bases: :py:obj:`abc.ABC`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: __eq__(other: typing_extensions.Self)

      Return self==value.


   .. py:method:: _array_safe_eq(a, b) -> bool
      :staticmethod:

      Check if a and b are equal, even if they are numpy arrays containing nans.


   .. py:method:: isequivalent(other: typing_extensions.Self, raise_: bool = False) -> bool

      Test whether the data structure between two objects are equivalent.

      Equivalence, in this case means that objects are compatible e.g. to be
      merged. Data content can vary, but e.g. the category of data (e.g.
      airway pressure, flow, tidal volume) and unit, etc., must match.


      :param other: object that will be compared to self.
      :param raise_: sets this method's behavior in case of non-equivalence. If
                     True, an `EquivalenceError` is raised, otherwise `False` is
                     returned.

      :raises EquivalenceError: if `raise_ == True` and the objects are not
      :raises equivalent.:

      :returns: bool describing result of equivalence comparison.



.. py:class:: VariantCollection(variant_type: type[V], *args, **kwargs)


   Bases: :py:obj:`dict`, :py:obj:`eitprocessing.mixins.equality.Equivalence`, :py:obj:`Generic`\ [\ :py:obj:`V`\ ]

   A collection of variants of a single type.

   A VariantCollection is a dictionary with some added features.

   A VariantCollection can only contain variants (of a certain type). When
   initializing VariantCollection a subclass of Variant (or Variant itself to
   allow diverse types )must be passed as the first argument (`variant_type`),
   limiting the type of variant that is allowed to be added to the collection.
   During initialization, other arguments can be passed as if initializing a
   normal dictionary.

   When adding a variant, the key of the item in the dictionary must equal the
   label of the variant. The method `add()` can be used instead, which
   automatically sets the variant label as the key.

   Thirdly, when setting a variant with a label that already exists, the
   default behaviour is to raise an exception. This prevents overwriting
   existing variants. This behaviour can be overridden using `add(variant,
   overwrite=True)`.


   The `add()` method

   Examples:
   ```
   >>> variant_a = EITDataVariant(label="raw", ...)
   >>> vc = VariantCollection(EITDataVariant, raw=variant_a)
   >>> variant_b = EITDataVariant(label="filtered", ...)
   >>> vc.add(variant_b)  # equals vc["filtered"] = variant
   ```

   ```
   >>> vc = VariantCollection(EITDataVariant)
   >>> variant_c = SomeOtherVariant(label="offset", ...)
   >>> vc.add(variant_c)  # raises InvalidVariantType() exception
   ```


   .. py:attribute:: variant_type
      :type: type[V]

      

   .. py:method:: __eq__(other: typing_extensions.Self)

      Return self==value.


   .. py:method:: __setitem__(__key: str, __value: V) -> None

      Set self[key] to value.


   .. py:method:: add(*variant: V, overwrite: bool = False) -> None

      Add one or multiple variants to the dictionary.

      This method automatically sets the key of the item to the label of the
      variant. By default, overwriting variants with the same label is
      prevented. Trying to do so will result in a DuplicateVariantLabel
      exception being raised. Set `overwrite` to `True` to allow overwriting.

      Args:
      - variant (Variant): the variant to be added. Multiple variants can be
      added at once.

      Raises:
      - DuplicateVariantLabel if one attempts to add a variant with a label
      that already exists as key.


   .. py:method:: _check_variant(variant: V, key=None, overwrite: bool = False) -> None


   .. py:method:: concatenate(a: typing_extensions.Self, b: typing_extensions.Self) -> typing_extensions.Self
      :classmethod:



.. py:class:: ContinuousData


   Bases: :py:obj:`eitprocessing.mixins.equality.Equivalence`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: name
      :type: str

      

   .. py:attribute:: unit
      :type: str

      

   .. py:attribute:: description
      :type: str

      

   .. py:attribute:: category
      :type: str

      

   .. py:attribute:: time
      :type: numpy.typing.NDArray

      

   .. py:attribute:: loaded
      :type: bool

      

   .. py:attribute:: calculated_from
      :type: Any | list[Any] | None

      

   .. py:attribute:: variants
      :type: eitprocessing.variants.variant_collection.VariantCollection

      

   .. py:method:: __post_init__()


   .. py:method:: concatenate(a: typing_extensions.Self, b: typing_extensions.Self) -> typing_extensions.Self
      :classmethod:



.. py:exception:: DataSourceUnknown


   Bases: :py:obj:`Exception`

   Raised when the source of data is unknown.


