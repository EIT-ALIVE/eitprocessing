eitprocessing.datahandling.datacollection
=========================================

.. py:module:: eitprocessing.datahandling.datacollection


Attributes
----------

.. autoapisummary::

   eitprocessing.datahandling.datacollection.V_classes
   eitprocessing.datahandling.datacollection.V


Classes
-------

.. autoapisummary::

   eitprocessing.datahandling.datacollection.ContinuousData
   eitprocessing.datahandling.datacollection.EITData
   eitprocessing.datahandling.datacollection.IntervalData
   eitprocessing.datahandling.datacollection.Equivalence
   eitprocessing.datahandling.datacollection.HasTimeIndexer
   eitprocessing.datahandling.datacollection.SparseData
   eitprocessing.datahandling.datacollection.DataCollection


Module Contents
---------------

.. py:class:: ContinuousData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`


   Container for data with a continuous time axis.

   Continuous data is assumed to be sequential (i.e. a single data point at each time point, sorted by time) and
   continuously measured/created at a fixed sampling rate. However, a fixed interval between consecutive time points is
   not enforced to account for floating point arithmetic, devices with imperfect sampling rates, and other sources of
   variation.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param unit: Unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'airway pressure'.
   :param description: Human readable extended description of the data.
   :param parameters: Parameters used to derive this data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param values: Data points.


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: parameters
      :type:  dict[str, typing_extensions.Any]


   .. py:attribute:: derived_from
      :type:  typing_extensions.Any | list[typing_extensions.Any]


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: values
      :type:  numpy.ndarray


   .. py:method:: __post_init__() -> None


   .. py:method:: __setattr__(attr: str, value: typing_extensions.Any)

      Implement setattr(self, name, value).



   .. py:method:: copy(label: str, *, name: str | None = None, unit: str | None = None, description: str | None = None, parameters: dict | None = None) -> typing_extensions.Self

      Create a copy.

      Whenever data is altered, it should probably be copied first. The alterations should then be made in the copy.



   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


   .. py:method:: derive(label: str, function: collections.abc.Callable, func_args: dict, **kwargs) -> typing_extensions.Self

      Create a copy deriving data from values attribute.

      :param label: New label for the derived object.
      :param function: Function that takes the values and returns the derived values.
      :param func_args: Arguments to pass to function.
      :param \*\*kwargs: New values for attributes of

      Example:
      ```
      def convert_data(x, add=None, subtract=None, multiply=None, divide=None):
          if add:
              x += add
          if subtract:
              x -= subtract
          if multiply:
              x *= multiply
          if divide:
              x /= divide
          return x


      data = ContinuousData(
          name="Lung volume (in mL)", label="volume_mL", unit="mL", category="volume", values=some_loaded_data
      )
      derived = data.derive("volume_L", convert_data, {"divide": 1000}, name="Lung volume (in L)", unit="L")
      ```



   .. py:method:: lock(*attr: str) -> None

      Lock attributes, essentially rendering them read-only.

      Locked attributes cannot be overwritten. Attributes can be unlocked using `unlock()`.

      :param \*attr: any number of attributes can be passed here, all of which will be locked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError



   .. py:method:: unlock(*attr: str) -> None

      Unlock attributes, rendering them editable.

      Locked attributes cannot be overwritten, but can be unlocked with this function to make them editable.

      :param \*attr: any number of attributes can be passed here, all of which will be unlocked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> data.unlock()
      >>> data.values = [1, 2, 3]
      >>> print(data.values)
      [1,2,3]
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> print(data.values)
      1



   .. py:property:: locked
      :type: bool

      Return whether the values attribute is locked.

      See lock().


   .. py:property:: loaded
      :type: bool

      Return whether the data was loaded from disk, or derived from elsewhere.


   .. py:method:: __len__()


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



.. py:class:: EITData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`


   Container for EIT impedance data.

   This class holds the pixel impedance from an EIT measurement, as well as metadata describing the measurement. The
   class is meant to hold data from (part of) a singular continuous measurement.

   This class can't be initialized directly. Instead, use `load_eit_data(<path>, vendor=<vendor>)` to load data from
   disk.

   :param path: The path of list of paths of the source from which data was derived.
   :param nframes: Number of frames.
   :param time: The time of each frame (since start measurement).
   :param framerate: The (average) rate at which the frames are collection, in Hz.
   :param vendor: The vendor of the device the data was collected with.
   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param pixel_impedance: Impedance values for each pixel at each frame.


   .. py:attribute:: path
      :type:  str | pathlib.Path | list[pathlib.Path | str]


   .. py:attribute:: nframes
      :type:  int


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: framerate
      :type:  float


   .. py:attribute:: vendor
      :type:  Vendor


   .. py:attribute:: label
      :type:  str | None


   .. py:attribute:: name
      :type:  str | None


   .. py:attribute:: pixel_impedance
      :type:  numpy.ndarray


   .. py:method:: __post_init__()


   .. py:method:: ensure_path_list(path: str | pathlib.Path | list[str | pathlib.Path]) -> list[pathlib.Path]
      :staticmethod:


      Return the path or paths as a list.

      The path of any EITData object can be a single str/Path or a list of str/Path objects. This method returns a
      list of Path objects given either a str/Path or list of str/Paths.



   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: __len__()


   .. py:method:: calculate_global_impedance() -> numpy.ndarray

      Return the global impedance, i.e. the sum of all included pixels at each frame.



.. py:class:: IntervalData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByIndex`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Container for interval data existing over a period of time.

   Interval data is data that consists for a given time interval. Examples are a ventilator setting (e.g.
   end-expiratory pressure), the position of a patient, a maneuver (end-expiratory hold) being performed, detected
   periods in the data, etc.

   Interval data consists of a number of intervals that may or may not have values associated with them.

   Examples of IntervalData with associated values are certain ventilator settings (e.g. end-expiratory pressure) and
   the position of a patient. Examples of IntervalData without associated values are indicators of maneouvres (e.g. a
   breath hold) or detected occurences (e.g. a breath).


   Interval data can be selected by time through the `select_by_time(start_time, end_time)` method. Alternatively,
   `t[start_time:end_time]` can be used.

   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param unit: The unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'breath'.
   :param intervals: A list of intervals (tuples containing a start time and end time).
   :param values: An optional list of values associated with each interval.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param description: Extended human readible description of the data.
   :param default_partial_inclusion: Whether to include a trimmed version of an interval when selecting data


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: intervals
      :type:  list[Interval | tuple[float, float]]


   .. py:attribute:: values
      :type:  list[Any] | None


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: default_partial_inclusion
      :type:  bool


   .. py:method:: __post_init__() -> None


   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the IntervalData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, partial_inclusion: bool | None = None, newlabel: str | None = None) -> typing_extensions.Self

      Create a new copy of the object, selecting data between start_time and end_time.

      This function returns a shortened copy of the object, containing data from the specified start_time to end_time.

      If `partial_inclusion` is set to `True`, any intervals that overlap with the start_time or end_time are included
      in the selection, and their times are adjusted to fit within the specified range. If `partial_inclusion` is
      `False`, intervals that overlap the start or end times are excluded from the selection.

      For example:
      - Set `partial_inclusion` to `True` for cases like "set_driving_pressure" where you want to include settings
      that were active before the start_time.
      - Set `partial_inclusion` to `False` for cases like "detected_breaths" where you want to exclude partial data
      that doesn't fully fit within the time range.

      Note that the end_time is always included in the selection if it is present in the original object.

      :param start_time: The earliest time point to include in the copy.
      :param end_time: The latest time point to include in the copy.
      :param partial_inclusion: Whether to include intervals that overlap with the start_time or end_time.
      :param newlabel: A new label for the copied object.



   .. py:method:: _keep_overlapping(interval: Interval, selection_start: float, selection_end: float, keep_partial_overlapping: bool) -> bool
      :staticmethod:


      Helper function for filtering overlapping interval-value pairs.



   .. py:method:: _replace_start_end_time(interval: Interval, selection_start: float, selection_end: float) -> Interval
      :staticmethod:


      Helper function to replace start and end time after filtering interval-value pairs.



   .. py:method:: __add__(other: typing_extensions.Self) -> typing_extensions.Self


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


.. py:class:: Equivalence

   Mixin class that adds an equality and equivalence check.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: _eq_dataclass(other: object) -> bool

      Compare two dataclasses for equality.



   .. py:method:: _eq_userdict(other: object) -> bool

      Compare two userdicts for equality.



   .. py:method:: _array_safe_eq(a: Any, b: Any) -> bool
      :staticmethod:


      Check if a and b are equal, even if they are numpy arrays containing nans.



   .. py:method:: isequivalent(other: typing_extensions.Self, raise_: bool = False) -> bool

      Test whether the data structure between two objects are equivalent.

      Equivalence, in this case means that objects are compatible e.g. to be
      merged. Data content can vary, but e.g. the category of data (e.g.
      airway pressure, flow, tidal volume) and unit, etc., must match.

      :param other: object that will be compared to self.
      :param raise_: sets this method's behavior in case of non-equivalence. If
                     True, an `EquivalenceError` is raised, otherwise `False` is
                     returned.

      :raises EquivalenceError: if `raise_ == True` and the objects are not
      :raises equivalent.:

      :returns: bool describing result of equivalence comparison.



.. py:class:: HasTimeIndexer

   Gives access to a TimeIndexer object that can be used to slice by time.


   .. py:property:: t
      :type: TimeIndexer

      Slicing an object using the time axis instead of indices.

      Example:
      ```
      >>> sequence = load_eit_data(<path>, ...)
      >>> time_slice1 = sequence.t[tp_start:tp_end]
      >>> time_slice2 = sequence.select_by_time(tp_start, tp_end)
      >>> time_slice1 == time_slice2
      True
      ```


   .. py:method:: select_by_time(*args, **kwargs) -> typing_extensions.Self
      :abstractmethod:



.. py:class:: SparseData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`


   Container for data related to individual time points.

   Sparse data is data for which the time points are not necessarily evenly spaced. Data can consist time-value pairs
   or only time points.


   Sparse data differs from interval data in that each data points is associated with a single time point rather than a
   time range.

   Examples are data points at end of inspiration/end of expiration (e.g. tidal volume, end-expiratoy lung impedance)
   or detected time points (e.g. QRS complexes).

   :param label: Computer readable name.
   :param name: Human readable name.
   :param unit: Unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'detected r peak'.
   :param description: Human readable extended description of the data.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param values: List or array of values. These van be numeric data, text or Python objects.


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: values
      :type:  Any | None
      :value: None



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the SparseData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: __add__(other: typing_extensions.Self) -> typing_extensions.Self


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


.. py:data:: V_classes

.. py:data:: V

.. py:class:: DataCollection(data_type: type[V], *args, **kwargs)

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`collections.UserDict`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`, :py:obj:`Generic`\ [\ :py:obj:`V`\ ]


   A collection of a single type of data with unique labels.

   A DataCollection functions largely as a dictionary, but requires a data_type argument, which must be one of the data
   containers existing in this package. When adding an item to the collection, the type of the value must match the
   data_type of the collection. Furthermore, the key has to match the attribute 'label' attached to the value.

   The convenience method `add()` adds an item by setting the key to `value.label`.

   :param data_type: the data container stored in this collection.


   .. py:attribute:: data_type
      :type:  type


   .. py:method:: __setitem__(__key: str, __value: V) -> None


   .. py:method:: add(*item: V, overwrite: bool = False) -> None

      Add one or multiple item(s) to the collection using the item label as the key.



   .. py:method:: _check_item(item: V, key: str | None = None, overwrite: bool = False) -> None

      Check whether the item can be added to the collection.

      In order to be added to the collection, the data type of the item has to match the data type set in the
      collection. They key that is used to store the item in the collection has to match the label of the item itself.
      By default, existing keys can not be overridden.

      :param item: Object to be added to the collection.
      :param key: Key of the item. Has to match `item.label`.
      :param overwrite: If False, the key can not already exist in the collection. Set to True to allow overwriting an
      :param existing object in the collection.:

      :raises TypeError: If the type of the item does not match the type set in the collection.
      :raises KeyError: If the key does not match `item.label`, or when the key already exists in de collection and
      :raises overwrite is set to False.:



   .. py:method:: get_loaded_data() -> dict[str, V]

      Return all data that was directly loaded from disk.



   .. py:method:: get_data_derived_from(obj: V) -> dict[str, V]

      Return all data that was derived from a specific source.



   .. py:method:: get_derived_data() -> dict[str, V]

      Return all data that was derived from any source.



   .. py:method:: concatenate(other: typing_extensions.Self) -> typing_extensions.Self

      Concatenate this collection with an equivalent collection.

      Each item of self of concatenated with the item of other with the same key.



   .. py:method:: select_by_time(start_time: float | None, end_time: float | None, start_inclusive: bool = True, end_inclusive: bool = False) -> DataCollection

      Return a DataCollection containing sliced copies of the items.



