eitprocessing.datahandling.loading
==================================

.. py:module:: eitprocessing.datahandling.loading


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/eitprocessing/datahandling/loading/binreader/index
   /autoapi/eitprocessing/datahandling/loading/draeger/index
   /autoapi/eitprocessing/datahandling/loading/sentec/index
   /autoapi/eitprocessing/datahandling/loading/timpel/index


Classes
-------

.. autoapisummary::

   eitprocessing.datahandling.loading.DataCollection
   eitprocessing.datahandling.loading.EITData
   eitprocessing.datahandling.loading.Vendor
   eitprocessing.datahandling.loading.Sequence


Functions
---------

.. autoapisummary::

   eitprocessing.datahandling.loading.load_eit_data
   eitprocessing.datahandling.loading._check_first_frame
   eitprocessing.datahandling.loading._ensure_vendor


Package Contents
----------------

.. py:class:: DataCollection(data_type: type[V], *args, **kwargs)

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`collections.UserDict`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`, :py:obj:`Generic`\ [\ :py:obj:`V`\ ]


   A collection of a single type of data with unique labels.

   This collection functions as a dictionary in most part. When initializing, a data type has to be passed. EITData,
   ContinuousData or SparseData is expected as the data type. Other types are allowed, but not supported. The objects
   added to the collection need to have a `label` attribute and a `concatenate()` method.

   When adding an item to the collection, the type of the value has to match the data type of the collection.
   Furthermore, the key has to match the attribute 'label' attached to the value.

   The convenience method `add()` adds an item by setting the key to `value.label`.

   :param data_type: the type of data stored in this collection.


   .. py:attribute:: data_type
      :type:  type


   .. py:method:: __setitem__(__key: str, __value: V) -> None


   .. py:method:: add(*item: V, overwrite: bool = False) -> None

      Add one or multiple item(s) to the collection.

      The item is added to the collection using the item label as the key.



   .. py:method:: _check_item(item: V, key: str | None = None, overwrite: bool = False) -> None

      Check whether the item can be added to the collection.

      In order to be added to the collection, the data type of the item has to match the data type set in the
      collection. They key that is used to store the item in the collection has to match the label of the item itself.
      By default, existing keys can not be overridden.

      :param item: Object to be added to the collection.
      :param key: Key of the item. Has to match `item.label`.
      :param overwrite: If False, the key can not already exist in the collection. Set to True to allow overwriting an
      :param existing object in the collection.:

      :raises TypeError: If the type of the item does not match the type set in the collection.
      :raises KeyError: If the key does not match `item.label`, or when the key already exists in de collection and
      :raises overwrite is set to False.:



   .. py:method:: get_loaded_data() -> dict[str, V]

      Return all data that was directly loaded from disk.



   .. py:method:: get_data_derived_from(obj: V) -> dict[str, V]

      Return all data that was derived from a specific source.



   .. py:method:: get_derived_data() -> dict[str, V]

      Return all data that was derived from any source.



   .. py:method:: concatenate(other: typing_extensions.Self) -> typing_extensions.Self

      Concatenate this collection with an equivalent collection.

      Each item of self of concatenated with the item of other with the same key.



   .. py:method:: select_by_time(start_time: float | None, end_time: float | None, start_inclusive: bool = True, end_inclusive: bool = False) -> DataCollection

      Return a DataCollection containing sliced copies of the items.



.. py:class:: EITData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`


   Container for EIT impedance data.

   This class holds the pixel impedance from an EIT measurement, as well as metadata describing the measurement. The
   class is meant to hold data from (part of) a singular continuous measurement.

   This class can't be initialized directly. Instead, use `load_eit_data(<path>, vendor=<vendor>)` to load data from
   disk.

   :param path: The path of list of paths of the source from which data was derived.
   :param nframes: Number of frames.
   :param time: The time of each frame (since start measurement).
   :param framerate: The (average) rate at which the frames are collection, in Hz.
   :param vendor: The vendor of the device the data was collected with.
   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param pixel_impedance: Impedance values for each pixel at each frame.


   .. py:attribute:: path
      :type:  str | pathlib.Path | list[pathlib.Path | str]


   .. py:attribute:: nframes
      :type:  int


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: framerate
      :type:  float


   .. py:attribute:: vendor
      :type:  Vendor


   .. py:attribute:: label
      :type:  str | None


   .. py:attribute:: name
      :type:  str | None


   .. py:attribute:: pixel_impedance
      :type:  numpy.ndarray


   .. py:method:: __post_init__()


   .. py:method:: parse_path(path: str | pathlib.Path | list[str | pathlib.Path], ensure_list: Literal[True]) -> list[pathlib.Path]
                  parse_path(path: str | pathlib.Path | list[str | pathlib.Path], ensure_list: Literal[False]) -> pathlib.Path
      :staticmethod:


      Return the path or paths as a list.

      The path of any EITData object can be a single str/Path or a list of str/Path objects. This method returns a
      list of Path objects given either a str/Path or list of str/Paths.



   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: __len__()


   .. py:method:: calculate_global_impedance() -> numpy.ndarray

      Return the global impedance, i.e. the sum of all included pixels at each frame.



.. py:class:: Vendor

   Bases: :py:obj:`strenum.LowercaseStrEnum`


   Enum indicating the vendor (manufacturer) of the source EIT device.


   .. py:attribute:: DRAEGER


   .. py:attribute:: TIMPEL


   .. py:attribute:: SENTEC


   .. py:attribute:: DRAGER


   .. py:attribute:: DRÃ„GER


.. py:class:: Sequence

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Sequence of timepoints containing respiratory data.

   A Sequence object is a representation of data points over time. These data can consist of any combination of EIT
   frames (`EITData`), waveform data (`ContinuousData`) from different sources, or individual events (`SparseData`)
   occurring at any given timepoint.
   A Sequence can consist of an entire measurement, a section of a measurement, a single breath, or even a portion of a
   breath. A Sequence can consist of multiple sets of each type of data from the same time-points or can be a single
   measurement from just one source.

   A Sequence can be split up into separate sections of a measurement or multiple (similar) Sequence objects can be
   merged together to form a single Sequence.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param description: Human readable extended description of the data.
   :param eit_data: Collection of one or more sets of EIT data frames.
   :param continuous_data: Collection of one or more sets of continuous data points.
   :param sparse_data: Collection of one or more sets of individual data points.


   .. py:attribute:: label
      :type:  str | None


   .. py:attribute:: name
      :type:  str | None


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: eit_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: continuous_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: sparse_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: interval_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:method:: __post_init__()


   .. py:property:: time
      :type: numpy.ndarray

      Time axis from either EITData or ContinuousData.


   .. py:method:: __len__()


   .. py:method:: __add__(other: Sequence) -> Sequence


   .. py:method:: concatenate(a: Sequence, b: Sequence, newlabel: str | None = None) -> Sequence
      :classmethod:


      Create a merge of two Sequence objects.



   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, start_inclusive: bool = True, end_inclusive: bool = False, label: str | None = None, name: str | None = None, description: str = '') -> typing_extensions.Self

      Return a sliced version of the Sequence.

      See SelectByTime.select_by_time().



.. py:function:: load_eit_data(path: str | pathlib.Path | list[str | pathlib.Path], vendor: eitprocessing.datahandling.eitdata.Vendor | str, label: str | None = None, name: str | None = None, description: str = '', framerate: float | None = None, first_frame: int = 0, max_frames: int | None = None) -> eitprocessing.datahandling.sequence.Sequence

   Load EIT data from path(s).

   :param path: relative or absolute path(s) to data file.
   :param vendor: vendor indicating the device used.
                  Note: for load functions of specific vendors (e.g. `load_draeger_data`), this argument is defaulted to the
                  correct vendor.
   :param label: short description of sequence for computer interpretation.
                 Defaults to "Sequence_<unique_id>".
   :param name: short description of sequence for human interpretation.
                Defaults to the same value as label.
   :param description: long description of sequence for human interpretation.
   :param framerate: framerate at which the data was recorded.
                     Default for Draeger: 20
                     Default for Timpel: 50
                     Default for Sentec: 50.2
   :param first_frame: index of first frame to load.
                       Defaults to 0.
   :param max_frames: maximum number of frames to load.
                      The actual number of frames can be lower than this if this
                      would surpass the final frame.

   :raises NotImplementedError: is raised when there is no loading method for
   :raises the given vendor.:

   :returns: a Sequence with the given label, name and description, containing the loaded data.
   :rtype: Sequence

   Example:
   ```
   sequence = load_data(["path/to/file1", "path/to/file2"], vendor="sentec", label="initial_measurement")
   pixel_impedance = sequence.eit_data["raw"].pixel_impedance
   ```


.. py:function:: _check_first_frame(first_frame: int | None) -> int

.. py:function:: _ensure_vendor(vendor: eitprocessing.datahandling.eitdata.Vendor | str) -> eitprocessing.datahandling.eitdata.Vendor

   Check whether vendor exists, and assure it's a Vendor object.


