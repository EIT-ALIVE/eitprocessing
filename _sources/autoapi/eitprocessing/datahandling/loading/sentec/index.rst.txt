eitprocessing.datahandling.loading.sentec
=========================================

.. py:module:: eitprocessing.datahandling.loading.sentec


Attributes
----------

.. autoapisummary::

   eitprocessing.datahandling.loading.sentec.SENTEC_FRAMERATE
   eitprocessing.datahandling.loading.sentec.load_sentec_data


Classes
-------

.. autoapisummary::

   eitprocessing.datahandling.loading.sentec.ContinuousData
   eitprocessing.datahandling.loading.sentec.DataCollection
   eitprocessing.datahandling.loading.sentec.EITData
   eitprocessing.datahandling.loading.sentec.Vendor
   eitprocessing.datahandling.loading.sentec.IntervalData
   eitprocessing.datahandling.loading.sentec.BinReader
   eitprocessing.datahandling.loading.sentec.SparseData
   eitprocessing.datahandling.loading.sentec.Domain
   eitprocessing.datahandling.loading.sentec.MeasurementDataID
   eitprocessing.datahandling.loading.sentec.ConfigurationDataID


Functions
---------

.. autoapisummary::

   eitprocessing.datahandling.loading.sentec.load_eit_data
   eitprocessing.datahandling.loading.sentec.load_from_single_path
   eitprocessing.datahandling.loading.sentec._read_frame


Module Contents
---------------

.. py:class:: ContinuousData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`


   Container for data with a continuous time axis.

   Continuous data is data that was continuously measured/created at a predictable rate. Therefore, continuous data is
   assumed to have a predictable delta between time points. A fixed delta is not enforced for two reasons: a) some
   devices have slightly varying sampling rate (but fixed around a set rate) and b) floating point arithmetic.

   Continuous data is assumed to be sequential (i.e. a single data point at each time point, sorted by time).

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param unit: Unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'airway pressure'.
   :param description: Human readable extended description of the data.
   :param parameters: Parameters used to derive this data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param values: Data points.


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: parameters
      :type:  dict[str, typing_extensions.Any]


   .. py:attribute:: derived_from
      :type:  typing_extensions.Any | list[typing_extensions.Any]


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: values
      :type:  numpy.ndarray


   .. py:method:: __post_init__() -> None


   .. py:method:: __setattr__(attr: str, value: typing_extensions.Any)

      Implement setattr(self, name, value).



   .. py:method:: copy(label: str, *, name: str | None = None, unit: str | None = None, description: str | None = None, parameters: dict | None = None) -> typing_extensions.Self

      Create a copy.

      Whenever data is altered, it should probably be copied first. The alterations should then be made in the copy.



   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


   .. py:method:: derive(label: str, function: collections.abc.Callable, func_args: dict, **kwargs) -> typing_extensions.Self

      Create a copy deriving data from values attribute.

      :param label: New label for the derived object.
      :param function: Function that takes the values and returns the derived values.
      :param func_args: Arguments to pass to function.
      :param \*\*kwargs: New values for attributes of

      Example:
      ```
      def convert_data(x, add=None, subtract=None, multiply=None, divide=None):
          if add:
              x += add
          if subtract:
              x -= subtract
          if multiply:
              x *= multiply
          if divide:
              x /= divide
          return x


      data = ContinuousData(
          name="Lung volume (in mL)", label="volume_mL", unit="mL", category="volume", values=some_loaded_data
      )
      derived = data.derive("volume_L", convert_data, {"divide": 1000}, name="Lung volume (in L)", unit="L")
      ```



   .. py:method:: lock(*attr: str) -> None

      Lock attributes, essentially rendering them read-only.

      Locked attributes cannot be overwritten. Attributes can be unlocked using `unlock()`.

      :param \*attr: any number of attributes can be passed here, all of which will be locked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError



   .. py:method:: unlock(*attr: str) -> None

      Unlock attributes, rendering them editable.

      Locked attributes cannot be overwritten, but can be unlocked with this function to make them editable.

      :param \*attr: any number of attributes can be passed here, all of which will be unlocked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> data.unlock()
      >>> data.values = [1, 2, 3]
      >>> print(data.values)
      [1,2,3]
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> print(data.values)
      1



   .. py:property:: locked
      :type: bool

      Return whether the values attribute is locked.

      See lock().


   .. py:property:: loaded
      :type: bool

      Return whether the data was loaded from disk, or derived from elsewhere.


   .. py:method:: __len__()


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



.. py:class:: DataCollection(data_type: type[V], *args, **kwargs)

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`collections.UserDict`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`, :py:obj:`Generic`\ [\ :py:obj:`V`\ ]


   A collection of a single type of data with unique labels.

   This collection functions as a dictionary in most part. When initializing, a data type has to be passed. EITData,
   ContinuousData or SparseData is expected as the data type. Other types are allowed, but not supported. The objects
   added to the collection need to have a `label` attribute and a `concatenate()` method.

   When adding an item to the collection, the type of the value has to match the data type of the collection.
   Furthermore, the key has to match the attribute 'label' attached to the value.

   The convenience method `add()` adds an item by setting the key to `value.label`.

   :param data_type: the type of data stored in this collection.


   .. py:attribute:: data_type
      :type:  type


   .. py:method:: __setitem__(__key: str, __value: V) -> None


   .. py:method:: add(*item: V, overwrite: bool = False) -> None

      Add one or multiple item(s) to the collection.

      The item is added to the collection using the item label as the key.



   .. py:method:: _check_item(item: V, key: str | None = None, overwrite: bool = False) -> None

      Check whether the item can be added to the collection.

      In order to be added to the collection, the data type of the item has to match the data type set in the
      collection. They key that is used to store the item in the collection has to match the label of the item itself.
      By default, existing keys can not be overridden.

      :param item: Object to be added to the collection.
      :param key: Key of the item. Has to match `item.label`.
      :param overwrite: If False, the key can not already exist in the collection. Set to True to allow overwriting an
      :param existing object in the collection.:

      :raises TypeError: If the type of the item does not match the type set in the collection.
      :raises KeyError: If the key does not match `item.label`, or when the key already exists in de collection and
      :raises overwrite is set to False.:



   .. py:method:: get_loaded_data() -> dict[str, V]

      Return all data that was directly loaded from disk.



   .. py:method:: get_data_derived_from(obj: V) -> dict[str, V]

      Return all data that was derived from a specific source.



   .. py:method:: get_derived_data() -> dict[str, V]

      Return all data that was derived from any source.



   .. py:method:: concatenate(other: typing_extensions.Self) -> typing_extensions.Self

      Concatenate this collection with an equivalent collection.

      Each item of self of concatenated with the item of other with the same key.



   .. py:method:: select_by_time(start_time: float | None, end_time: float | None, start_inclusive: bool = True, end_inclusive: bool = False) -> DataCollection

      Return a DataCollection containing sliced copies of the items.



.. py:class:: EITData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`


   Container for EIT impedance data.

   This class holds the pixel impedance from an EIT measurement, as well as metadata describing the measurement. The
   class is meant to hold data from (part of) a singular continuous measurement.

   This class can't be initialized directly. Instead, use `load_eit_data(<path>, vendor=<vendor>)` to load data from
   disk.

   :param path: The path of list of paths of the source from which data was derived.
   :param nframes: Number of frames.
   :param time: The time of each frame (since start measurement).
   :param framerate: The (average) rate at which the frames are collection, in Hz.
   :param vendor: The vendor of the device the data was collected with.
   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param pixel_impedance: Impedance values for each pixel at each frame.


   .. py:attribute:: path
      :type:  str | pathlib.Path | list[pathlib.Path | str]


   .. py:attribute:: nframes
      :type:  int


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: framerate
      :type:  float


   .. py:attribute:: vendor
      :type:  Vendor


   .. py:attribute:: label
      :type:  str | None


   .. py:attribute:: name
      :type:  str | None


   .. py:attribute:: pixel_impedance
      :type:  numpy.ndarray


   .. py:method:: __post_init__()


   .. py:method:: parse_path(path: str | pathlib.Path | list[str | pathlib.Path], ensure_list: Literal[True]) -> list[pathlib.Path]
                  parse_path(path: str | pathlib.Path | list[str | pathlib.Path], ensure_list: Literal[False]) -> pathlib.Path
      :staticmethod:


      Return the path or paths as a list.

      The path of any EITData object can be a single str/Path or a list of str/Path objects. This method returns a
      list of Path objects given either a str/Path or list of str/Paths.



   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: __len__()


   .. py:method:: calculate_global_impedance() -> numpy.ndarray

      Return the global impedance, i.e. the sum of all included pixels at each frame.



.. py:class:: Vendor

   Bases: :py:obj:`strenum.LowercaseStrEnum`


   Enum indicating the vendor (manufacturer) of the source EIT device.


   .. py:attribute:: DRAEGER


   .. py:attribute:: TIMPEL


   .. py:attribute:: SENTEC


   .. py:attribute:: DRAGER


   .. py:attribute:: DRÄGER


.. py:class:: IntervalData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByIndex`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Container for interval data existing over a period of time.

   Interval data is data that consists for a given time interval. Examples are a ventilator setting (e.g.
   end-expiratory pressure), the position of a patient, a maneuver (end-expiratory hold) being performed, detected
   periods in the data, etc.

   Interval data consists of a number of intervals that may or may not have values associated with them.

   Examples of IntervalData with associated values are certain ventilator settings (e.g. end-expiratory pressure) and
   the position of a patient. Examples of IntervalData without associated values are indicators of maneouvres (e.g. a
   breath hold) or detected occurences (e.g. a breath).


   Interval data can be selected by time through the `select_by_time(start_time, end_time)` method. Alternatively,
   `t[start_time:end_time]` can be used.

   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param unit: The unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'breath'.
   :param intervals: A list of intervals (tuples containing a start time and end time).
   :param values: An optional list of values associated with each interval.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param description: Extended human readible description of the data.
   :param default_partial_inclusion: Whether to include a trimmed version of an interval when selecting data


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: intervals
      :type:  list[Interval | tuple[float, float]]


   .. py:attribute:: values
      :type:  list[Any] | None


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: default_partial_inclusion
      :type:  bool


   .. py:method:: __post_init__() -> None


   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the IntervalData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, partial_inclusion: bool | None = None, newlabel: str | None = None) -> typing_extensions.Self

      Get a shortened copy of the object, starting from start_time and ending at end_time.

      When the start or end time overlaps with an interval, the interval and its associated value are included in
      the selection if `partial_inclusion` is `True`, but ignored if `partial_inclusion` is `False`. If the interval
      is partially included, the start and end times are trimmed to the start and end time of the selection. A
      potential use case where `partial_inclusion` should be set to `True` is "set_driving_pressure": you might want
      to keep the driving pressure that was set before the start of the selectioon. A use case where
      `partial_inclusion` should be set to `False` is "detected_breaths": you might want to ignore partial breaths
      that started before or ended after the selected period.

      Note that when selecting by time, the end time is always included in the selection if it exists in the original
      object.

      :param start_time: earliest time point to include in the copy
      :param end_time: latest time point to include in the copy
      :param partial_inclusion: whether to include an interval that contains the start_time or end_time
      :param newlabel: new label of the copied object



   .. py:method:: _keep_overlapping(item: tuple[Interval, Any], selection_start: float, selection_end: float, keep_partial_overlapping: bool) -> bool
      :staticmethod:


      Helper function for filtering overlapping interval-value pairs.



   .. py:method:: _replace_start_end_time(interval: Interval, selection_start: float, selection_end: float) -> Interval
      :staticmethod:


      Helper function to replace start and end time after filtering interval-value pairs.



   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


.. py:function:: load_eit_data(path: str | pathlib.Path | list[str | pathlib.Path], vendor: eitprocessing.datahandling.eitdata.Vendor | str, label: str | None = None, name: str | None = None, description: str = '', framerate: float | None = None, first_frame: int = 0, max_frames: int | None = None) -> eitprocessing.datahandling.sequence.Sequence

   Load EIT data from path(s).

   :param path: relative or absolute path(s) to data file.
   :param vendor: vendor indicating the device used.
                  Note: for load functions of specific vendors (e.g. `load_draeger_data`), this argument is defaulted to the
                  correct vendor.
   :param label: short description of sequence for computer interpretation.
                 Defaults to "Sequence_<unique_id>".
   :param name: short description of sequence for human interpretation.
                Defaults to the same value as label.
   :param description: long description of sequence for human interpretation.
   :param framerate: framerate at which the data was recorded.
                     Default for Draeger: 20
                     Default for Timpel: 50
                     Default for Sentec: 50.2
   :param first_frame: index of first frame to load.
                       Defaults to 0.
   :param max_frames: maximum number of frames to load.
                      The actual number of frames can be lower than this if this
                      would surpass the final frame.

   :raises NotImplementedError: is raised when there is no loading method for
   :raises the given vendor.:

   :returns: a Sequence with the given label, name and description, containing the loaded data.
   :rtype: Sequence

   Example:
   ```
   sequence = load_data(["path/to/file1", "path/to/file2"], vendor="sentec", label="initial_measurement")
   pixel_impedance = sequence.eit_data["raw"].pixel_impedance
   ```


.. py:class:: BinReader

   Helper class for reading binary files from disk.

   :param file_handle: a buffered reader handle, e.g. the result of the `open()` function.
   :param endian: the endianness of the binary data. Either 'little' or 'big', or None.


   .. py:attribute:: file_handle
      :type:  io.BufferedReader | mmap.mmap


   .. py:attribute:: endian
      :type:  Literal['little', 'big'] | None
      :value: None



   .. py:method:: read_single(type_code: str, cast: type[T]) -> T

      Read and return a single unit of the given type code.

      The type of data to be read should be provided as a single typ code. See
      https://docs.python.org/3.10/library/struct.html#byte-order-size-and-alignment for a list of available type
      codes.

      A unit returns a single value, and can be one or more bytes of data. E.g. requesting a signed 32-bit integer
      ('q') will result in reading 8 bytes of data.

      `cast` should be a type, e.g. `int` or `float` used to cast the value to the proper type.

      :param type_code: singular type code.
      :param cast: the associated type.



   .. py:method:: read_list(type_code: str, cast: type[T], length: int) -> list[T]

      Read multiple values of the same type and return as list.

      See `read_single()`.

      :param type_code: singular type code.
      :param cast: the associated type.
      :param length: number of values to be read.



   .. py:method:: read_array(type_code: str, cast: type[N], length: int) -> numpy.typing.NDArray[N]

      Read multiple values of the same type and return as NumPy array.

      See `read_list()`.



   .. py:method:: read_string(length: int = 1) -> str

      Read and return a string with a given length.

      Reads `length` characters of type code 's' and returns as a string. When length is not provided, a single
      character is returned.

      :param length: number of characters.



   .. py:attribute:: string


   .. py:method:: _read_full_type_code(full_type_code: str) -> tuple[Any, Ellipsis]

      Read the data associated with the type code.



   .. py:method:: float32() -> float

      Read and return a single signed 32-bit floating point value.



   .. py:method:: float64() -> float

      Read and return a single signed 64-bit floating point value.



   .. py:method:: npfloat32(length: int = 1) -> numpy.typing.NDArray[numpy.float32]

      Read and return an array of signed 32-bit floating point values.



   .. py:method:: npfloat64(length: int = 1) -> numpy.typing.NDArray[numpy.float64]

      Read and return an array of signed 64-bit floating point values.



   .. py:method:: int32() -> int

      Read and return a single signed 32-bit integer value.



   .. py:method:: npint32(length: int = 1) -> numpy.typing.NDArray[numpy.int32]

      Read and return an array of signed 32-bit integer values.



   .. py:method:: uint8() -> int

      Read and return a single unsigned 8-bit integer value.



   .. py:method:: uint16() -> int

      Read and return a single unsigned 16-bit integer value.



   .. py:method:: uint32() -> int

      Read and return a single unsigned 32-bit integer value.



   .. py:method:: uint64() -> int

      Read and return a single unsigned 64-bit integer value.



.. py:class:: SparseData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`


   Container for data related to individual time points.

   Sparse data is data for which the time points are not necessarily evenly spaced. Data can consist time-value pairs
   or only time points. Values generally are numeric values in arrays, but can also be lists of different types of
   object.

   Sparse data is assumed to be sequential (i.e. only a single data points at a single time point, and sorted by time).
   Sparse data can contain zero or more time points/time-values pairs.

   Sparse data differs from interval data in that each data points is associated with a single time point rather than a
   time range.

   Examples are data points at end of inspiration/end of expiration (e.g. tidal volume, end-expiratoy lung impedance)
   or detected time points (e.g. QRS complexes).

   :param label: Computer readable name.
   :param name: Human readable name.
   :param unit: Unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'detected r peak'.
   :param description: Human readable extended description of the data.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param values: List or array of values. These van be numeric data, text or Python objects.


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: values
      :type:  Any | None
      :value: None



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the SparseData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


.. py:data:: SENTEC_FRAMERATE
   :value: 50.2


.. py:data:: load_sentec_data

.. py:function:: load_from_single_path(path: pathlib.Path, framerate: float | None = 50.2, first_frame: int = 0, max_frames: int | None = None) -> dict[str, eitprocessing.datahandling.datacollection.DataCollection]

   Load Sentec EIT data from path.


.. py:function:: _read_frame(fh: BinaryIO | mmap.mmap, version: int, index: int, payload_size: int, reader: eitprocessing.datahandling.loading.binreader.BinReader, first_frame: int = 0) -> numpy.typing.NDArray | None

   Read a single frame in the file.

   The current position of the file has to be already set to the point where the image should be read (data_id 5).

   :param fh: opened file object
   :param version: version of the Sentec file
   :param index: current number of read frames
   :param payload_size: size of the payload of the data to be read.
   :param reader: bites reader object
   :param first_frame: index of first time point of sequence.

   Returns: A 32 x 32 matrix, containing the pixels values.



.. py:class:: Domain

   Bases: :py:obj:`enum.IntEnum`


   Domain loaded data falls in.


   .. py:attribute:: MEASUREMENT
      :value: 16



   .. py:attribute:: CONFIGURATION
      :value: 64



.. py:class:: MeasurementDataID

   Bases: :py:obj:`enum.IntEnum`


   ID of measured data.


   .. py:attribute:: TIMESTAMP
      :value: 0



   .. py:attribute:: ZERO_REF_IMAGE
      :value: 5



.. py:class:: ConfigurationDataID

   Bases: :py:obj:`enum.IntEnum`


   ID of configuration data.


   .. py:attribute:: FRAMERATE
      :value: 1



