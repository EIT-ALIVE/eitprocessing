eitprocessing.datahandling.continuousdata
=========================================

.. py:module:: eitprocessing.datahandling.continuousdata


Attributes
----------

.. autoapisummary::

   eitprocessing.datahandling.continuousdata.T


Classes
-------

.. autoapisummary::

   eitprocessing.datahandling.continuousdata.ContinuousData


Module Contents
---------------

.. py:data:: T

.. py:class:: ContinuousData

   Bases: :py:obj:`eitprocessing.datahandling.DataContainer`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`


   Container for data with a continuous time axis.

   Continuous data is assumed to be sequential (i.e. a single data point at each time point, sorted by time) and
   continuously measured/created at a fixed sampling frequency. However, a fixed interval between consecutive time
   points is not enforced to account for floating point arithmetic, devices with imperfect sampling frequencies, and
   other sources of variation.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param unit: Unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'airway pressure'.
   :param description: Human readable extended description of the data.
   :param parameters: Parameters used to derive this data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param values: Data points.


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: parameters
      :type:  dict[str, typing_extensions.Any]


   .. py:attribute:: derived_from
      :type:  typing_extensions.Any | list[typing_extensions.Any]


   .. py:attribute:: time
      :type:  numpy.ndarray


   .. py:attribute:: values
      :type:  numpy.ndarray


   .. py:method:: __post_init__() -> None


   .. py:method:: __setattr__(attr: str, value: typing_extensions.Any)

      Implement setattr(self, name, value).



   .. py:method:: copy(label: str, *, name: str | None = None, unit: str | None = None, description: str | None = None, parameters: dict | None = None) -> typing_extensions.Self

      Create a copy.

      Whenever data is altered, it should probably be copied first. The alterations should then be made in the copy.



   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


   .. py:method:: derive(label: str, function: collections.abc.Callable, func_args: dict | None = None, **kwargs) -> typing_extensions.Self

      Create a copy deriving data from values attribute.

      :param label: New label for the derived object.
      :param function: Function that takes the values and returns the derived values.
      :param func_args: Arguments to pass to function, if any.
      :param \*\*kwargs: Values for changed attributes of derived object.

      Example:
      ```
      def convert_data(x, add=None, subtract=None, multiply=None, divide=None):
          if add:
              x += add
          if subtract:
              x -= subtract
          if multiply:
              x *= multiply
          if divide:
              x /= divide
          return x


      data = ContinuousData(
          name="Lung volume (in mL)", label="volume_mL", unit="mL", category="volume", values=some_loaded_data
      )
      derived = data.derive("volume_L", convert_data, {"divide": 1000}, name="Lung volume (in L)", unit="L")
      ```



   .. py:method:: lock(*attr: str) -> None

      Lock attributes, essentially rendering them read-only.

      Locked attributes cannot be overwritten. Attributes can be unlocked using `unlock()`.

      :param \*attr: any number of attributes can be passed here, all of which will be locked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError



   .. py:method:: unlock(*attr: str) -> None

      Unlock attributes, rendering them editable.

      Locked attributes cannot be overwritten, but can be unlocked with this function to make them editable.

      :param \*attr: any number of attributes can be passed here, all of which will be unlocked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> data.unlock()
      >>> data.values = [1, 2, 3]
      >>> print(data.values)
      [1,2,3]
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> print(data.values)
      1



   .. py:property:: locked
      :type: bool

      Return whether the values attribute is locked.

      See lock().


   .. py:property:: loaded
      :type: bool

      Return whether the data was loaded from disk, or derived from elsewhere.


   .. py:method:: __len__()


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



