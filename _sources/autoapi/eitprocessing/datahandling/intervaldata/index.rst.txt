eitprocessing.datahandling.intervaldata
=======================================

.. py:module:: eitprocessing.datahandling.intervaldata


Attributes
----------

.. autoapisummary::

   eitprocessing.datahandling.intervaldata.T


Classes
-------

.. autoapisummary::

   eitprocessing.datahandling.intervaldata.Equivalence
   eitprocessing.datahandling.intervaldata.HasTimeIndexer
   eitprocessing.datahandling.intervaldata.SelectByIndex
   eitprocessing.datahandling.intervaldata.Interval
   eitprocessing.datahandling.intervaldata.IntervalData


Module Contents
---------------

.. py:class:: Equivalence

   Mixin class that adds an equality and equivalence check.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: _eq_dataclass(other: object) -> bool

      Compare two dataclasses for equality.



   .. py:method:: _eq_userdict(other: object) -> bool

      Compare two userdicts for equality.



   .. py:method:: _array_safe_eq(a: Any, b: Any) -> bool
      :staticmethod:


      Check if a and b are equal, even if they are numpy arrays containing nans.



   .. py:method:: isequivalent(other: typing_extensions.Self, raise_: bool = False) -> bool

      Test whether the data structure between two objects are equivalent.

      Equivalence, in this case means that objects are compatible e.g. to be
      merged. Data content can vary, but e.g. the category of data (e.g.
      airway pressure, flow, tidal volume) and unit, etc., must match.

      :param other: object that will be compared to self.
      :param raise_: sets this method's behavior in case of non-equivalence. If
                     True, an `EquivalenceError` is raised, otherwise `False` is
                     returned.

      :raises EquivalenceError: if `raise_ == True` and the objects are not
      :raises equivalent.:

      :returns: bool describing result of equivalence comparison.



.. py:class:: HasTimeIndexer

   Gives access to a TimeIndexer object that can be used to slice by time.


   .. py:property:: t
      :type: TimeIndexer

      Slicing an object using the time axis instead of indices.

      Example:
      ```
      >>> sequence = load_eit_data(<path>, ...)
      >>> time_slice1 = sequence.t[tp_start:tp_end]
      >>> time_slice2 = sequence.select_by_time(tp_start, tp_end)
      >>> time_slice1 == time_slice2
      True
      ```


   .. py:method:: select_by_time(*args, **kwargs) -> typing_extensions.Self
      :abstractmethod:



.. py:class:: SelectByIndex

   Bases: :py:obj:`abc.ABC`


   Adds slicing functionality to subclass by implementing `__getitem__`.

   Subclasses must implement a `_sliced_copy` function that defines what should
   happen when the object is sliced. This class ensures that when calling a
   slice between square brackets (as e.g. done for lists) then return the
   expected sliced object.


   .. py:attribute:: label
      :type:  str


   .. py:method:: __getitem__(key: slice | int)


   .. py:method:: select_by_index(start: int | None = None, end: int | None = None, newlabel: str | None = None) -> typing_extensions.Self

      De facto implementation of the `__getitem__` function.

      This function can also be called directly to add a label to the sliced
      object. Otherwise a default label describing the slice and original
      object is attached.



   .. py:method:: __len__()
      :abstractmethod:



   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self
      :abstractmethod:


      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



.. py:data:: T

.. py:class:: Interval

   Bases: :py:obj:`NamedTuple`


   A tuple containing the start time and end time of an interval.


   .. py:attribute:: start_time
      :type:  float


   .. py:attribute:: end_time
      :type:  float


.. py:class:: IntervalData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByIndex`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Container for interval data existing over a period of time.

   Interval data is data that consists for a given time interval. Examples are a ventilator setting (e.g.
   end-expiratory pressure), the position of a patient, a maneuver (end-expiratory hold) being performed, detected
   periods in the data, etc.

   Interval data consists of a number of intervals that may or may not have values associated with them.

   Examples of IntervalData with associated values are certain ventilator settings (e.g. end-expiratory pressure) and
   the position of a patient. Examples of IntervalData without associated values are indicators of maneouvres (e.g. a
   breath hold) or detected occurences (e.g. a breath).


   Interval data can be selected by time through the `select_by_time(start_time, end_time)` method. Alternatively,
   `t[start_time:end_time]` can be used.

   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param unit: The unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'breath'.
   :param intervals: A list of intervals (tuples containing a start time and end time).
   :param values: An optional list of values associated with each interval.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param description: Extended human readible description of the data.
   :param default_partial_inclusion: Whether to include a trimmed version of an interval when selecting data


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: intervals
      :type:  list[Interval | tuple[float, float]]


   .. py:attribute:: values
      :type:  list[Any] | None


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: default_partial_inclusion
      :type:  bool


   .. py:method:: __post_init__() -> None


   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the IntervalData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, partial_inclusion: bool | None = None, newlabel: str | None = None) -> typing_extensions.Self

      Get a shortened copy of the object, starting from start_time and ending at end_time.

      When the start or end time overlaps with an interval, the interval and its associated value are included in
      the selection if `partial_inclusion` is `True`, but ignored if `partial_inclusion` is `False`. If the interval
      is partially included, the start and end times are trimmed to the start and end time of the selection. A
      potential use case where `partial_inclusion` should be set to `True` is "set_driving_pressure": you might want
      to keep the driving pressure that was set before the start of the selectioon. A use case where
      `partial_inclusion` should be set to `False` is "detected_breaths": you might want to ignore partial breaths
      that started before or ended after the selected period.

      Note that when selecting by time, the end time is always included in the selection if it exists in the original
      object.

      :param start_time: earliest time point to include in the copy
      :param end_time: latest time point to include in the copy
      :param partial_inclusion: whether to include an interval that contains the start_time or end_time
      :param newlabel: new label of the copied object



   .. py:method:: _keep_overlapping(item: tuple[Interval, Any], selection_start: float, selection_end: float, keep_partial_overlapping: bool) -> bool
      :staticmethod:


      Helper function for filtering overlapping interval-value pairs.



   .. py:method:: _replace_start_end_time(interval: Interval, selection_start: float, selection_end: float) -> Interval
      :staticmethod:


      Helper function to replace start and end time after filtering interval-value pairs.



   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


