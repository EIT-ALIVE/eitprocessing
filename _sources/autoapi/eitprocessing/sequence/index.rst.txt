:py:mod:`eitprocessing.sequence`
================================

.. py:module:: eitprocessing.sequence


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   eitprocessing.sequence.ContinuousData
   eitprocessing.sequence.DataCollection
   eitprocessing.sequence.EITData
   eitprocessing.sequence.Equivalence
   eitprocessing.sequence.SelectByTime
   eitprocessing.sequence.SparseData
   eitprocessing.sequence.Sequence




.. py:class:: ContinuousData


   Bases: :py:obj:`eitprocessing.mixins.equality.Equivalence`, :py:obj:`eitprocessing.mixins.slicing.SelectByTime`

   Data class for (non-EIT) data with a continuous time axis.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param unit: Unit for the data.
   :param category: Category the data falls into, e.g. 'airway pressure'.
   :param description: Human readable extended description of the data.
   :param parameters: Parameters used to derive this data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param values: Data points.

   .. py:property:: locked
      :type: bool

      Return whether the values attribute is locked.

      See lock().

   .. py:property:: loaded
      :type: bool

      Return whether the data was loaded from disk, or derived from elsewhere.

   .. py:attribute:: label
      :type: str

      

   .. py:attribute:: name
      :type: str

      

   .. py:attribute:: unit
      :type: str

      

   .. py:attribute:: category
      :type: str

      

   .. py:attribute:: description
      :type: str
      :value: ''

      

   .. py:attribute:: parameters
      :type: dict[str, typing_extensions.Any]

      

   .. py:attribute:: derived_from
      :type: typing_extensions.Any | list[typing_extensions.Any]

      

   .. py:attribute:: time
      :type: numpy.ndarray

      

   .. py:attribute:: values
      :type: numpy.ndarray

      

   .. py:method:: __post_init__() -> None


   .. py:method:: __setattr__(attr: str, value: typing_extensions.Any)

      Implement setattr(self, name, value).


   .. py:method:: copy(label: str, *, name: str | None = None, unit: str | None = None, description: str | None = None, parameters: dict | None = None) -> typing_extensions.Self

      Create a copy.

      Whenever data is altered, it should probably be copied first. The alterations should then be made in the copy.


   .. py:method:: derive(label: str, function: collections.abc.Callable, func_args: dict, **kwargs) -> typing_extensions.Self

      Create a copy deriving data from values attribute.

      :param label: New label for the derived object.
      :param function: Function that takes the values and returns the derived values.
      :param func_args: Arguments to pass to function.
      :param \*\*kwargs: New values for attributes of

      Example:
      ```
      def convert_data(x, add=None, subtract=None, multiply=None, divide=None):
          if add:
              x += add
          if subtract:
              x -= subtract
          if multiply:
              x *= multiply
          if divide:
              x /= divide
          return x


      data = ContinuousData(
          name="Lung volume (in mL)", label="volume_mL", unit="mL", category="volume", values=some_loaded_data
      )
      derived = data.derive("volume_L", convert_data, {"divide": 1000}, name="Lung volume (in L)", unit="L")
      ```


   .. py:method:: lock(*attr: str) -> None

      Lock attributes, essentially rendering them read-only.

      Locked attributes cannot be overwritten. Attributes can be unlocked using `unlock()`.

      :param \*attr: any number of attributes can be passed here, all of which will be locked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError


   .. py:method:: unlock(*attr: str) -> None

      Unlock attributes, rendering them editable.

      Locked attributes cannot be overwritten, but can be unlocked with this function to make them editable.

      :param \*attr: any number of attributes can be passed here, all of which will be unlocked. Defaults to "values".

      .. rubric:: Examples

      >>> # lock the `values` attribute of `data`
      >>> data.lock()
      >>> data.values = [1, 2, 3] # will result in an AttributeError
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> data.unlock()
      >>> data.values = [1, 2, 3]
      >>> print(data.values)
      [1,2,3]
      >>> data.values[0] = 1      # will result in a RuntimeError
      >>> print(data.values)
      1


   .. py:method:: __len__()


   .. py:method:: _sliced_copy(start_index: int, end_index: int, label: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



.. py:class:: DataCollection(data_type: type[V], *args, **kwargs)


   Bases: :py:obj:`dict`, :py:obj:`eitprocessing.mixins.equality.Equivalence`, :py:obj:`Generic`\ [\ :py:obj:`V`\ ]

   A collection of a single type of data with unique labels.

   This collection functions as a dictionary in most part. When initializing, a data type has to be passed. EITData,
   ContinuousData or SparseData is expected as the data type. Other types are allowed, but not supported. The objects
   added to the collection need to have a `label` attribute and a `concatenate()` method.

   When adding an item to the collection, the type of the value has to match the data type of the collection.
   Furthermore, the key has to match the attribute 'label' attached to the value.

   The convenience method `add()` adds an item by setting the key to `value.label`.

   :param data_type: the type of data stored in this collection. Expected to be one of EITData, ContinuousData or
   :param SparseData.:

   .. py:attribute:: data_type
      :type: type

      

   .. py:method:: __setitem__(__key: str, __value: V) -> None

      Set self[key] to value.


   .. py:method:: add(*item: V, overwrite: bool = False) -> None

      Add one or multiple item(s) to the collection.


   .. py:method:: _check_item(item: V, key: str | None = None, overwrite: bool = False) -> None

      Check whether the item can be added to the collection.

      In order to be added to the collection, the data type of the item has to match the data type set in the
      collection. They key that is used to store the item in the collection has to match the label of the item itself.
      By default, existing keys can not be overridden.

      :param item: Object to be added to the collection.
      :param key: Key of the item. Has to match `item.label`.
      :param overwrite: If False, the key can not already exist in the collection. Set to True to allow overwriting an
      :param existing object in the collection.:

      :raises TypeError: If the type of the item does not match the type set in the collection.
      :raises KeyError: If the key does not match `item.label`, or when the key already exists in de collection and
      :raises overwrite is set to False.:


   .. py:method:: get_loaded_data() -> dict[str, V]

      Return all data that was directly loaded from disk.


   .. py:method:: get_data_derived_from(obj: V) -> dict[str, V]

      Return all data that was derived from a specific source.


   .. py:method:: get_derived_data() -> dict[str, V]

      Return all data that was derived from any source.


   .. py:method:: concatenate(other: typing_extensions.Self[V]) -> typing_extensions.Self[V]

      Concatenate this collection with an equivalent collection.

      Each item of self of concatenated with the item of other with the same key.



.. py:class:: EITData


   Bases: :py:obj:`eitprocessing.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.mixins.equality.Equivalence`

   Container for EIT data.

   This class holds the pixel impedance from an EIT measurement, as well as metadata describing the measurement. The
   class is meant to hold data from (part of) a singular continuous measurement.

   This class can't be initialized directly. Instead, use `EITData.from_path(...)` to load data from disk.
   Currently, loading data from three vendors is supported. You can either pass the vendor when using
   `EITData.from_path(..., vendor="timpel")`, or use one of the available subclasses of EITData:
   `SentecEITData.from_path(...)`.

   Several convenience methods are supplied for calculating global impedance, calculating or removing baselines, etc.

   .. py:property:: global_baseline
      :type: numpy.ndarray

      Return the global baseline, i.e. the minimum pixel impedance across all pixels.

   .. py:property:: pixel_impedance_global_offset
      :type: numpy.ndarray

      Return the pixel impedance with the global baseline removed.

      In the resulting array the minimum impedance across all pixels is set to 0.

   .. py:property:: pixel_baseline
      :type: numpy.ndarray

      Return the lowest value in each individual pixel over time.

   .. py:property:: pixel_impedance_individual_offset
      :type: numpy.ndarray

      Return the pixel impedance with the baseline of each individual pixel removed.

      Each pixel in the resulting array has a minimum value of 0.

   .. py:property:: global_impedance
      :type: numpy.ndarray

      Return the global impedance, i.e. the sum of all pixels at each frame.

   .. py:attribute:: path
      :type: pathlib.Path | list[pathlib.Path]

      

   .. py:attribute:: nframes
      :type: int

      

   .. py:attribute:: time
      :type: numpy.typing.NDArray

      

   .. py:attribute:: framerate
      :type: float

      

   .. py:attribute:: vendor
      :type: vendor.Vendor

      

   .. py:attribute:: phases
      :type: list

      

   .. py:attribute:: events
      :type: list

      

   .. py:attribute:: label
      :type: str | None

      

   .. py:attribute:: pixel_impedance
      :type: numpy.typing.NDArray

      

   .. py:method:: __post_init__()


   .. py:method:: ensure_path_list(path: str | pathlib.Path | list[str | pathlib.Path]) -> list[pathlib.Path]
      :staticmethod:

      Return the path or paths as a list.

      The path of any EITData object can be a single str/Path or a list of str/Path objects. This method returns a
      list of Path objects given either a str/Path or list of str/Paths.


   .. py:method:: __add__(other: T) -> T


   .. py:method:: concatenate(other: T, label: str | None = None) -> T


   .. py:method:: _sliced_copy(start_index: int, end_index: int, label: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.


   .. py:method:: __len__()



.. py:class:: Equivalence


   Mixin class that adds an equality and equivalence check.

   .. py:method:: __eq__(other: typing_extensions.Self)

      Return self==value.


   .. py:method:: _array_safe_eq(a: Any, b: Any) -> bool
      :staticmethod:

      Check if a and b are equal, even if they are numpy arrays containing nans.


   .. py:method:: isequivalent(other: typing_extensions.Self, raise_: bool = False) -> bool

      Test whether the data structure between two objects are equivalent.

      Equivalence, in this case means that objects are compatible e.g. to be
      merged. Data content can vary, but e.g. the category of data (e.g.
      airway pressure, flow, tidal volume) and unit, etc., must match.


      :param other: object that will be compared to self.
      :param raise_: sets this method's behavior in case of non-equivalence. If
                     True, an `EquivalenceError` is raised, otherwise `False` is
                     returned.

      :raises EquivalenceError: if `raise_ == True` and the objects are not
      :raises equivalent.:

      :returns: bool describing result of equivalence comparison.



.. py:class:: SelectByTime


   Bases: :py:obj:`SelectByIndex`

   Adds methods for slicing by time rather than index.

   .. py:property:: t
      :type: TimeIndexer

      Time Indexer property.

   .. py:attribute:: time
      :type: numpy.typing.NDArray

      

   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, start_inclusive: bool = True, end_inclusive: bool = False, label: str | None = None) -> typing_extensions.Self

      Get a slice from start to end time stamps.

      Given a start and end time stamp (i.e. its value, not its index),
      return a slice of the original object, which must contain a time axis.

      :param start_time: first time point to include. Defaults to first frame of sequence.
      :param end_time: last time point. Defaults to last frame of sequence.
      :param start_inclusive (default: `True`), end_inclusive (default `False`):
                                       these arguments control the behavior if the given time stamp
                                       does not match exactly with an existing time stamp of the input.
                                       if `True`: the given time stamp will be inside the sliced object.
                                       if `False`: the given time stamp will be outside the sliced object.
      :param label: Description. Defaults to None, which will create a label based
                    on the original object label and the frames by which it is sliced.

      :raises TypeError: if `self` does not contain a `time` attribute.
      :raises ValueError: if time stamps are not sorted.

      :returns: Slice of self.



.. py:class:: SparseData


   SparseData.


.. py:class:: Sequence


   Bases: :py:obj:`eitprocessing.mixins.equality.Equivalence`, :py:obj:`eitprocessing.mixins.slicing.SelectByTime`

   Sequence of timepoints containing respiratory data.

   A Sequence object is a representation of data points over time. These data can consist of any combination of EIT
   frames (`EITData`), waveform data (`ContinuousData`) from different sources, or individual events (`SparseData`)
   occurring at any given timepoint.
   A Sequence can consist of an entire measurement, a section of a measurement, a single breath, or even a portion of a
   breath. A Sequence can consist of multiple sets of each type of data from the same time-points or can be a single
   measurement from just one source.

   A Sequence can be split up into separate sections of a measurement or multiple (similar) Sequence objects can be
   merged together to form a single Sequence.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param description: Human readable extended description of the data.
   :param eit_data: Collection of one or more sets of EIT data frames.
   :param continuous_data: Collection of one or more sets of continuous data points.
   :param sparse_data: Collection of one or more sets of individual data points.

   .. py:property:: time
      :type: numpy.ndarray

      Time axis from either EITData or ContinuousData.

   .. py:attribute:: label
      :type: str | None

      

   .. py:attribute:: name
      :type: str | None

      

   .. py:attribute:: description
      :type: str
      :value: ''

      

   .. py:attribute:: eit_data
      :type: eitprocessing.data_collection.DataCollection

      

   .. py:attribute:: continuous_data
      :type: eitprocessing.data_collection.DataCollection

      

   .. py:attribute:: sparse_data
      :type: eitprocessing.data_collection.DataCollection

      

   .. py:method:: __post_init__()


   .. py:method:: __len__()


   .. py:method:: __add__(other: Sequence) -> Sequence


   .. py:method:: concatenate(a: Sequence, b: Sequence) -> Sequence
      :classmethod:

      Create a merge of two Sequence objects.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, label: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



