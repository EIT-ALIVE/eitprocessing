eitprocessing.features.pixel_inflation
======================================

.. py:module:: eitprocessing.features.pixel_inflation


Classes
-------

.. autoapisummary::

   eitprocessing.features.pixel_inflation.BreathDetection
   eitprocessing.features.pixel_inflation.Breath
   eitprocessing.features.pixel_inflation.IntervalData
   eitprocessing.features.pixel_inflation.Sequence
   eitprocessing.features.pixel_inflation.PixelInflation


Module Contents
---------------

.. py:class:: BreathDetection

   Algorithm for detecting breaths in data representing respiration.

   This algorithm detects the position of breaths in data by detecting valleys
   (local minimum values) and peaks (local maximum values) in data. When
   initializing BreathDetection, the sample frequency of the data and the
   minimum duration of a breath have to be provided. The minimum duration
   should be short enough to include the shortest expected breath in the data.

   Examples:
   >>> bd = BreathDetection(sample_frequency=50, minimum_duration=0.5)
   >>> breaths = bd.find_breaths(global_impedance)


   .. py:attribute:: sample_frequency
      :type:  float


   .. py:attribute:: minimum_distance
      :type:  float


   .. py:attribute:: averaging_window_length
      :type:  float
      :value: 15



   .. py:attribute:: averaging_window_fun
      :type:  collections.abc.Callable[[int], numpy.typing.ArrayLike] | None


   .. py:attribute:: amplitude_cutoff_fraction
      :type:  float | None
      :value: 0.25



   .. py:attribute:: invalid_data_removal_window_length
      :type:  float
      :value: 1



   .. py:attribute:: invalid_data_removal_percentile
      :type:  int
      :value: 5



   .. py:attribute:: invalid_data_removal_multiplier
      :type:  int
      :value: 4



   .. py:method:: _find_features(data: numpy.ndarray, moving_average: numpy.ndarray, invert: float = False) -> tuple[numpy.ndarray, numpy.ndarray]

      Find features (peaks or valleys) in the data.

      This method finds features (either peaks or valleys) in the data using
      the `scipy.signal.find_peaks()` function. The minimum distance (in
      time) between peaks is determined by the `minimum_distance` attribute.

      To find peaks, `invert` should be False. To find valleys, `invert`
      should be True, which flips the data before finding peaks.

      :param data: a 1D array containing the data.
      :type data: np.ndarray
      :param moving_average: a 1D array containing the moving average
                             of the data.
      :type moving_average: NDArrag
      :param invert: whether to invert the data before
      :type invert: float, optional
      :param detecting peaks. Defaults to False.:

      :returns: A tuple containing two 1D arrays of length N with the indices (int)
                and values (float) of the features, where N is the number of
                features found.



   .. py:method:: _remove_edge_cases(peak_indices: numpy.ndarray, peak_values: numpy.ndarray, valley_indices: numpy.ndarray, valley_values: numpy.ndarray, data: numpy.ndarray, moving_average: numpy.ndarray) -> _PeakValleyData

      Remove overdetected peaks/valleys at the start and end of the data.

      This method removed a valley at the start of the data, if the data
      before said valley stays below the moving average of the data at said
      valley. Likewise, it removes the last valley if the data after the last
      valley stays below the moving average of the data at said valley. This
      ensures a valley is a true valley, and not just a local minimum while
      the true valley is cut off.

      Then, all peaks that occur before the first and after the last valley
      are removed. This ensures peaks only fall between valleys.

      :param peak_indices: indices of the peaks
      :type peak_indices: np.ndarray
      :param peak_values: values of the peaks
      :type peak_values: np.ndarray
      :param valley_indices: indices of the valleys
      :type valley_indices: np.ndarray
      :param valley_values: values of the valleys
      :type valley_values: np.ndarray
      :param data: the data in which the peaks/valleys were detected
      :type data: np.ndarray
      :param moving_average: the moving average of data
      :type moving_average: np.ndarray

      :returns: A tuple (peak_indices, peak_values, valley_indices, valley_values)
                with edge cases removed.



   .. py:method:: _remove_doubles(peak_indices: numpy.ndarray, peak_values: numpy.ndarray, valley_indices: numpy.ndarray, valley_values: numpy.ndarray) -> _PeakValleyData

      Remove double peaks/valleys.

      This method ensures there is only one peak between valleys, and only
      one valley between peaks. If there are multiple peaks between two
      valleys, the peak with the highest value is kept and the others are
      removed. If there are no peaks between several valleys (i.e. multiple
      valleys between peaks) the valley with the lowest value is kept, while
      the others are removed.

      This method does not remove peaks before the first or after the last
      valley.

      :param peak_indices: indices of the peaks
      :type peak_indices: np.ndarray
      :param peak_values: values of the peaks
      :type peak_values: np.ndarray
      :param valley_indices: indices of the valleys
      :type valley_indices: np.ndarray
      :param valley_values: values of the valleys
      :type valley_values: np.ndarray

      :returns: A tuple (peak_indices, peak_values, valley_indices, valley_values)
                with double peaks/valleys removed.



   .. py:method:: _remove_low_amplitudes(peak_indices: numpy.ndarray, peak_values: numpy.ndarray, valley_indices: numpy.ndarray, valley_values: numpy.ndarray) -> _PeakValleyData

      Remove peaks if the amplitude is low compared to the median amplitude.

      The amplitude of a peak is determined as the average vertical distance
      between the peak value and the two valley values besides it. The cutoff
      value for the amplitude is calculated as the median amplitude times
      `amplitude_cutoff_fraction`. Peaks that have an amplitude below the
      cutoff are removed. Then, `_remove_doubles()` is called to remove
      either of the valleys next to the peak.

      If `amplitude_cutoff_fraction` is None, the input is returned
      unchanged.

      :param peak_indices: the indices of the peaks
      :type peak_indices: np.ndarray
      :param peak_values: the values of the peaks
      :type peak_values: np.ndarray
      :param valley_indices: the indices of the valleys
      :type valley_indices: np.ndarray
      :param valley_values: the values of the valleys
      :type valley_values: np.ndarray

      :returns: A tuple (peak_indices, peak_values, valley_indices, valley_values)
                with low-amplitude breaths removed.



   .. py:method:: _remove_breaths_around_invalid_data(breaths: list[eitprocessing.datahandling.breath.Breath], data: numpy.ndarray, time: numpy.ndarray) -> list[eitprocessing.datahandling.breath.Breath]


   .. py:method:: find_breaths(sequence: eitprocessing.datahandling.sequence.Sequence, continuousdata_label: str) -> eitprocessing.datahandling.intervaldata.IntervalData

      Find breaths in the data.

      This method attempts to find peaks and valleys in the data in a
      multi-step process. First, it naively finds any peaks that are a
      certain distance apart and higher than the moving average, and
      similarly valleys that are a certain distance apart and below the
      moving average.

      Next, valleys at the start and end of the signal are removed
      to ensure the first and last valleys are actual valleys, and not just
      the start or end of the signal. Peaks before the first or after the
      last valley are removed, to ensure peaks always fall between two
      valleys.

      At this point, it is possible multiple peaks exist between two valleys.
      Lower peaks are removed leaving only the highest peak between two
      valleys. Similarly, multiple valleys between two peaks are reduced to
      only the lowest valley.

      As a last step, breaths with a low amplitude (the average between the
      inspiratory and expiratory amplitudes) are removed.

      Breaths are constructed as a valley-peak-valley combination,
      representing the start of inspiration, the end of inspiration/start of
      expiration, and end of expiration.

      :param sequence: the sequence that contains the data
      :param continuousdata_label: label of the continuous data to apply the algorithm to

      :returns: A list of Breath objects.



.. py:class:: Breath

   Bases: :py:obj:`NamedTuple`


   Represents a breath with a start, middle and end index.


   .. py:attribute:: start_time
      :type:  float


   .. py:attribute:: middle_time
      :type:  float


   .. py:attribute:: end_time
      :type:  float


.. py:class:: IntervalData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByIndex`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Container for interval data existing over a period of time.

   Interval data is data that consists for a given time interval. Examples are a ventilator setting (e.g.
   end-expiratory pressure), the position of a patient, a maneuver (end-expiratory hold) being performed, detected
   periods in the data, etc.

   Interval data consists of a number of intervals that may or may not have values associated with them.

   Examples of IntervalData with associated values are certain ventilator settings (e.g. end-expiratory pressure) and
   the position of a patient. Examples of IntervalData without associated values are indicators of maneouvres (e.g. a
   breath hold) or detected occurences (e.g. a breath).


   Interval data can be selected by time through the `select_by_time(start_time, end_time)` method. Alternatively,
   `t[start_time:end_time]` can be used.

   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param unit: The unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'breath'.
   :param intervals: A list of intervals (tuples containing a start time and end time).
   :param values: An optional list of values associated with each interval.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param description: Extended human readible description of the data.
   :param default_partial_inclusion: Whether to include a trimmed version of an interval when selecting data


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: intervals
      :type:  list[Interval | tuple[float, float]]


   .. py:attribute:: values
      :type:  list[Any] | None


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: default_partial_inclusion
      :type:  bool


   .. py:method:: __post_init__() -> None


   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the IntervalData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, partial_inclusion: bool | None = None, newlabel: str | None = None) -> typing_extensions.Self

      Create a new copy of the object, selecting data between start_time and end_time.

      This function returns a shortened copy of the object, containing data from the specified start_time to end_time.

      If `partial_inclusion` is set to `True`, any intervals that overlap with the start_time or end_time are included
      in the selection, and their times are adjusted to fit within the specified range. If `partial_inclusion` is
      `False`, intervals that overlap the start or end times are excluded from the selection.

      For example:
      - Set `partial_inclusion` to `True` for cases like "set_driving_pressure" where you want to include settings
      that were active before the start_time.
      - Set `partial_inclusion` to `False` for cases like "detected_breaths" where you want to exclude partial data
      that doesn't fully fit within the time range.

      Note that the end_time is always included in the selection if it is present in the original object.

      :param start_time: The earliest time point to include in the copy.
      :param end_time: The latest time point to include in the copy.
      :param partial_inclusion: Whether to include intervals that overlap with the start_time or end_time.
      :param newlabel: A new label for the copied object.



   .. py:method:: _keep_overlapping(interval: Interval, selection_start: float, selection_end: float, keep_partial_overlapping: bool) -> bool
      :staticmethod:


      Helper function for filtering overlapping interval-value pairs.



   .. py:method:: _replace_start_end_time(interval: Interval, selection_start: float, selection_end: float) -> Interval
      :staticmethod:


      Helper function to replace start and end time after filtering interval-value pairs.



   .. py:method:: __add__(other: typing_extensions.Self) -> typing_extensions.Self


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


.. py:class:: Sequence

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Sequence of timepoints containing respiratory data.

   A Sequence object is a representation of data points over time. These data can consist of any combination of EIT
   frames (`EITData`), waveform data (`ContinuousData`) from different sources, or individual events (`SparseData`)
   occurring at any given timepoint.
   A Sequence can consist of an entire measurement, a section of a measurement, a single breath, or even a portion of a
   breath. A Sequence can consist of multiple sets of each type of data from the same time-points or can be a single
   measurement from just one source.

   A Sequence can be split up into separate sections of a measurement or multiple (similar) Sequence objects can be
   merged together to form a single Sequence.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param description: Human readable extended description of the data.
   :param eit_data: Collection of one or more sets of EIT data frames.
   :param continuous_data: Collection of one or more sets of continuous data points.
   :param sparse_data: Collection of one or more sets of individual data points.


   .. py:attribute:: label
      :type:  str | None


   .. py:attribute:: name
      :type:  str | None


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: eit_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: continuous_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: sparse_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: interval_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:method:: __post_init__()


   .. py:property:: time
      :type: numpy.ndarray

      Time axis from either EITData or ContinuousData.


   .. py:method:: __len__()


   .. py:method:: __add__(other: Sequence) -> Sequence


   .. py:method:: concatenate(a: Sequence, b: Sequence, newlabel: str | None = None) -> Sequence
      :classmethod:


      Create a merge of two Sequence objects.



   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, start_inclusive: bool = True, end_inclusive: bool = False, label: str | None = None, name: str | None = None, description: str = '') -> typing_extensions.Self

      Return a sliced version of the Sequence.

      See SelectByTime.select_by_time().



.. py:class:: PixelInflation

   Algorithm for detecting timing of pixel inflation and deflation in pixel impedance data.

   This algorithm detects the position of start inflation, end inflation/start deflation and
   end deflation in pixel impedance data. It uses BreathDetection to find the global start and end
   of inspiration and expiration. These points are then used to find the start/end of pixel
   inflation/deflation in pixel impedance data.

   Examples:
   pi = PixelInflation(sample_frequency=FRAMERATE)
   pixel_inflations = pi.find_pixel_inflations(sequence, eitdata_label='low pass filtered',continuousdata_label='global_impedance_(raw)')


   .. py:attribute:: sample_frequency
      :type:  float


   .. py:attribute:: breath_detection_kwargs
      :type:  dict


   .. py:method:: find_pixel_inflations(sequence: eitprocessing.datahandling.sequence.Sequence, eitdata_label: str, continuousdata_label: str) -> eitprocessing.datahandling.intervaldata.IntervalData

      Find pixel inflations in the data.

      This methods finds the pixel start/end of inflation/deflation
      based on the global start/end of inspiration/expiration.
      Pixel start of inflation is defined as the local minimum between
      two global end-inspiration points. Pixel end of deflation is defined
      as the local minimum between the consecutive two global end-inspiration
      points. Pixel end of inflation is defined as the local maximum between
      pixel start of inflation and end of deflation.

      Pixel inflations are constructed as a valley-peak-valley combination,
      representing the start of inflation, the end of inflation/start of
      deflation, and end of deflation.

      :param sequence: the sequence that contains the data
      :param eitdata_label: label of eit data to apply the algorithm to
      :param continuousdata_label: label of the continuous data to use for global breath detection

      :returns: np.ndarray, where each element contains a list of PixelInflation objects



