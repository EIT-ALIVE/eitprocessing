eitprocessing.features.breath_detection
=======================================

.. py:module:: eitprocessing.features.breath_detection


Classes
-------

.. autoapisummary::

   eitprocessing.features.breath_detection.Breath
   eitprocessing.features.breath_detection.IntervalData
   eitprocessing.features.breath_detection.Sequence
   eitprocessing.features.breath_detection.MovingAverage
   eitprocessing.features.breath_detection.BreathDetection


Module Contents
---------------

.. py:class:: Breath

   Represents a breath with a start, middle and end index.


   .. py:attribute:: start_time
      :type:  float


   .. py:attribute:: middle_time
      :type:  float


   .. py:attribute:: end_time
      :type:  float


   .. py:method:: __post_init__()


   .. py:method:: __iter__() -> collections.abc.Iterator[float]


.. py:class:: IntervalData

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByIndex`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Container for interval data existing over a period of time.

   Interval data is data that consists for a given time interval. Examples are a ventilator setting (e.g.
   end-expiratory pressure), the position of a patient, a maneuver (end-expiratory hold) being performed, detected
   periods in the data, etc.

   Interval data consists of a number of intervals that may or may not have values associated with them.

   Examples of IntervalData with associated values are certain ventilator settings (e.g. end-expiratory pressure) and
   the position of a patient. Examples of IntervalData without associated values are indicators of maneouvres (e.g. a
   breath hold) or detected occurences (e.g. a breath).


   Interval data can be selected by time through the `select_by_time(start_time, end_time)` method. Alternatively,
   `t[start_time:end_time]` can be used.

   :param label: Computer readable label identifying this dataset.
   :param name: Human readable name for the data.
   :param unit: The unit of the data, if applicable.
   :param category: Category the data falls into, e.g. 'breath'.
   :param intervals: A list of intervals (tuples containing a start time and end time).
   :param values: An optional list of values associated with each interval.
   :param parameters: Parameters used to derive the data.
   :param derived_from: Traceback of intermediates from which the current data was derived.
   :param description: Extended human readible description of the data.
   :param default_partial_inclusion: Whether to include a trimmed version of an interval when selecting data


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: unit
      :type:  str | None


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: intervals
      :type:  list[Interval | tuple[float, float]]


   .. py:attribute:: values
      :type:  list[Any] | None


   .. py:attribute:: parameters
      :type:  dict[str, Any]


   .. py:attribute:: derived_from
      :type:  list[Any]


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: default_partial_inclusion
      :type:  bool


   .. py:method:: __post_init__() -> None


   .. py:method:: __len__() -> int


   .. py:property:: has_values
      :type: bool

      True if the IntervalData has values, False otherwise.


   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, partial_inclusion: bool | None = None, newlabel: str | None = None) -> typing_extensions.Self

      Create a new copy of the object, selecting data between start_time and end_time.

      This function returns a shortened copy of the object, containing data from the specified start_time to end_time.

      If `partial_inclusion` is set to `True`, any intervals that overlap with the start_time or end_time are included
      in the selection, and their times are adjusted to fit within the specified range. If `partial_inclusion` is
      `False`, intervals that overlap the start or end times are excluded from the selection.

      For example:
      - Set `partial_inclusion` to `True` for cases like "set_driving_pressure" where you want to include settings
      that were active before the start_time.
      - Set `partial_inclusion` to `False` for cases like "detected_breaths" where you want to exclude partial data
      that doesn't fully fit within the time range.

      Note that the end_time is always included in the selection if it is present in the original object.

      :param start_time: The earliest time point to include in the copy.
      :param end_time: The latest time point to include in the copy.
      :param partial_inclusion: Whether to include intervals that overlap with the start_time or end_time.
      :param newlabel: A new label for the copied object.



   .. py:method:: _keep_overlapping(interval: Interval, selection_start: float, selection_end: float, keep_partial_overlapping: bool) -> bool
      :staticmethod:


      Helper function for filtering overlapping interval-value pairs.



   .. py:method:: _replace_start_end_time(interval: Interval, selection_start: float, selection_end: float) -> Interval
      :staticmethod:


      Helper function to replace start and end time after filtering interval-value pairs.



   .. py:method:: __add__(other: typing_extensions.Self) -> typing_extensions.Self


   .. py:method:: concatenate(other: T, newlabel: str | None = None) -> T


.. py:class:: Sequence

   Bases: :py:obj:`eitprocessing.datahandling.mixins.equality.Equivalence`, :py:obj:`eitprocessing.datahandling.mixins.slicing.SelectByTime`, :py:obj:`eitprocessing.datahandling.mixins.slicing.HasTimeIndexer`


   Sequence of timepoints containing respiratory data.

   A Sequence object is a representation of data points over time. These data can consist of any combination of EIT
   frames (`EITData`), waveform data (`ContinuousData`) from different sources, or individual events (`SparseData`)
   occurring at any given timepoint.
   A Sequence can consist of an entire measurement, a section of a measurement, a single breath, or even a portion of a
   breath. A Sequence can consist of multiple sets of each type of data from the same time-points or can be a single
   measurement from just one source.

   A Sequence can be split up into separate sections of a measurement or multiple (similar) Sequence objects can be
   merged together to form a single Sequence.

   :param label: Computer readable naming of the instance.
   :param name: Human readable naming of the instance.
   :param description: Human readable extended description of the data.
   :param eit_data: Collection of one or more sets of EIT data frames.
   :param continuous_data: Collection of one or more sets of continuous data points.
   :param sparse_data: Collection of one or more sets of individual data points.


   .. py:attribute:: label
      :type:  str | None


   .. py:attribute:: name
      :type:  str | None


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: eit_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: continuous_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: sparse_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:attribute:: interval_data
      :type:  eitprocessing.datahandling.datacollection.DataCollection


   .. py:method:: __post_init__()


   .. py:property:: time
      :type: numpy.ndarray

      Time axis from either EITData or ContinuousData.


   .. py:method:: __len__()


   .. py:method:: __add__(other: Sequence) -> Sequence


   .. py:method:: concatenate(a: Sequence, b: Sequence, newlabel: str | None = None) -> Sequence
      :classmethod:


      Create a merge of two Sequence objects.



   .. py:method:: _sliced_copy(start_index: int, end_index: int, newlabel: str) -> typing_extensions.Self

      Slicing method that must be implemented by all subclasses.

      Must return a copy of self object with all attached data within selected
      indices.



   .. py:method:: select_by_time(start_time: float | None = None, end_time: float | None = None, start_inclusive: bool = True, end_inclusive: bool = False, label: str | None = None, name: str | None = None, description: str = '') -> typing_extensions.Self

      Return a sliced version of the Sequence.

      See SelectByTime.select_by_time().



.. py:class:: MovingAverage

   Calculate the moving average of the data.

   The moving average is calculated using a convolution with a window. The
   window length (in seconds) is determined by the attribute
   `averaging_window_duration`. The shape of the window is determined by
   `averaging_window_fun`, which should be a callable that takes an
   integer `M` and returns an array-like sequence containing a window with
   length `M` and area 1.

   Before convolution the data is padded. The padding type is 'edge' by
   default. See `np.pad()` for more information. Padding adds values at the
   start and end with the first/last value, to more accurately determine the
   average at the boundaries of the data.

   :param window_size: the size of the window. Is enlarged by 1 if uneven.
   :param window_fun: window function, e.g. np.window.bartlett.

   :returns: Moving average as a 1D array with the same length as `data`.


   .. py:attribute:: window_size
      :type:  int


   .. py:attribute:: window_fun
      :type:  collections.abc.Callable | None
      :value: None



   .. py:attribute:: padding_type
      :type:  str
      :value: 'edge'



   .. py:method:: __post_init__()


   .. py:method:: apply(data: numpy.ndarray) -> numpy.ndarray

      Apply the moving average on the data.

      :param data: input data as 1D array
      :type data: NDArray



.. py:class:: BreathDetection

   Algorithm for detecting breaths in data representing respiration.

   This algorithm detects the position of breaths in data by detecting valleys
   (local minimum values) and peaks (local maximum values) in data. When
   initializing BreathDetection, the sample frequency of the data and the
   minimum duration of a breath have to be provided. The minimum duration
   should be short enough to include the shortest expected breath in the data.

   Examples:
   >>> bd = BreathDetection(sample_frequency=50, minimum_distance=0.5)
   >>> breaths = bd.find_breaths(sequency=seq, continuousdata_label="global_impedance_(raw)")

   :param sample_frequency: sample frequency of the data
   :param minimum_distance: minimum expected distance between breaths, defaults to 0.67 seconds
   :param averaging_window_length: length of window used for averaging the data, defaults to 15 seconds
   :param averaging_window_fun: function used to average the data, defaults to np.blackman
   :param amplitude_cutoff_fraction: fraction of the median amplitude below which breaths are removed
   :param invalid_data_removal_window_length: window around invalid data in which breaths are removed
   :param invalid_data_removal_percentile: the nth percentile of values used to remove outliers
   :param invalid_data_removal_multiplier: the multiplier used to remove outliers


   .. py:attribute:: sample_frequency
      :type:  float


   .. py:attribute:: minimum_distance
      :type:  float


   .. py:attribute:: averaging_window_length
      :type:  float
      :value: 15



   .. py:attribute:: averaging_window_fun
      :type:  collections.abc.Callable[[int], numpy.typing.ArrayLike] | None


   .. py:attribute:: amplitude_cutoff_fraction
      :type:  float | None
      :value: 0.25



   .. py:attribute:: invalid_data_removal_window_length
      :type:  float
      :value: 0.5



   .. py:attribute:: invalid_data_removal_percentile
      :type:  int
      :value: 5



   .. py:attribute:: invalid_data_removal_multiplier
      :type:  int
      :value: 4



   .. py:method:: find_breaths(sequence: eitprocessing.datahandling.sequence.Sequence, continuousdata_label: str) -> eitprocessing.datahandling.intervaldata.IntervalData

      Find breaths in the data.

      This method attempts to find peaks and valleys in the data in a
      multi-step process. First, it naively finds any peaks that are a
      certain distance apart and higher than the moving average, and
      similarly valleys that are a certain distance apart and below the
      moving average.

      Next, valleys at the start and end of the signal are removed
      to ensure the first and last valleys are actual valleys, and not just
      the start or end of the signal. Peaks before the first or after the
      last valley are removed, to ensure peaks always fall between two
      valleys.

      At this point, it is possible multiple peaks exist between two valleys.
      Lower peaks are removed leaving only the highest peak between two
      valleys. Similarly, multiple valleys between two peaks are reduced to
      only the lowest valley.

      As a last step, breaths with a low amplitude (the average between the
      inspiratory and expiratory amplitudes) are removed.

      Breaths are constructed as a valley-peak-valley combination,
      representing the start of inspiration, the end of inspiration/start of
      expiration, and end of expiration.

      :param sequence: the sequence that contains the data
      :param continuousdata_label: label of the continuous data to apply the algorithm to

      :returns: A list of Breath objects.



   .. py:method:: _find_features(data: numpy.ndarray, moving_average: numpy.ndarray, invert: float = False) -> numpy.ndarray

      Find features (peaks or valleys) in the data.

      This method finds features (either peaks or valleys) in the data using
      the `scipy.signal.find_peaks()` function. The minimum distance (in
      time) between peaks is determined by the `minimum_distance` attribute.

      To find peaks, `invert` should be False. To find valleys, `invert`
      should be True, which flips the data before finding peaks.

      :param data: a 1D array containing the data.
      :type data: np.ndarray
      :param moving_average: a 1D array containing the moving average
                             of the data.
      :type moving_average: NDArrag
      :param invert: whether to invert the data before
      :type invert: float, optional
      :param detecting peaks. Defaults to False.:

      :returns: A tuple containing two 1D arrays of length N with the indices (int)
                and values (float) of the features, where N is the number of
                features found.



   .. py:method:: _remove_edge_cases(data: numpy.ndarray, peak_indices: numpy.ndarray, valley_indices: numpy.ndarray, moving_average: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]

      Remove overdetected peaks/valleys at the start and end of the data.

      This method removes a valley at the start of the data if the data before said valley stays below the moving
      average of the data at said valley. Likewise, it removes the last valley if the data after the last valley stays
      below the moving average of the data at said valley. This ensures a valley is a true valley, and not just a
      local minimum while the true valley is cut off.

      Then, all peaks that occur before the first and after the last valley
      are removed. This ensures peaks only fall between valleys.

      :param peak_indices: indices of the peaks
      :type peak_indices: np.ndarray
      :param peak_values: values of the peaks
      :type peak_values: np.ndarray
      :param valley_indices: indices of the valleys
      :type valley_indices: np.ndarray
      :param valley_values: values of the valleys
      :type valley_values: np.ndarray
      :param data: the data in which the peaks/valleys were detected
      :type data: np.ndarray
      :param moving_average: the moving average of data
      :type moving_average: np.ndarray

      :returns: A tuple (peak_indices, peak_values, valley_indices, valley_values)
                with edge cases removed.



   .. py:method:: _remove_doubles(data: numpy.ndarray, peak_indices: numpy.ndarray, valley_indices: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]

      Remove double peaks/valleys.

      This method ensures there is only one peak between valleys, and only
      one valley between peaks. If there are multiple peaks between two
      valleys, the peak with the highest value is kept and the others are
      removed. If there are no peaks between several valleys (i.e. multiple
      valleys between peaks) the valley with the lowest value is kept, while
      the others are removed.

      This method does not remove peaks before the first or after the last
      valley.

      :param data: data the peaks and valleys were found in
      :param peak_indices: indices of the peaks
      :param valley_indices: indices of the valleys

      :returns: A tuple (peak_indices, peak_values, valley_indices, valley_values)
                with double peaks/valleys removed.



   .. py:method:: _remove_low_amplitudes(data: numpy.ndarray, peak_indices: numpy.ndarray, valley_indices: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]

      Remove peaks if the amplitude is low compared to the median amplitude.

      The amplitude of a peak is determined as the average vertical distance
      between the peak value and the two valley values besides it. The cutoff
      value for the amplitude is calculated as the median amplitude times
      `amplitude_cutoff_fraction`. Peaks that have an amplitude below the
      cutoff are removed. Then, `_remove_doubles()` is called to remove
      either of the valleys next to the peak.

      If `amplitude_cutoff_fraction` is None, the input is returned
      unchanged.

      :param data: the data the peaks and valleys were found in
      :param peak_indices: the indices of the peaks
      :type peak_indices: np.ndarray
      :param valley_indices: the indices of the valleys
      :type valley_indices: np.ndarray

      :returns: A tuple (peak_indices, peak_values, valley_indices, valley_values)
                with low-amplitude breaths removed.



   .. py:method:: _remove_breaths_around_invalid_data(breaths: list[eitprocessing.datahandling.breath.Breath], time: numpy.ndarray, outliers: numpy.ndarray) -> list[eitprocessing.datahandling.breath.Breath]

      Remove breaths overlapping with invalid data.

      This function defines a lower and upper cutoff. Data beyond those cutoffs is considered invalid for the
      purposes of breath detection. Breaths that start within a window length of invalid data are removed.

      The lower cutoff is a distance away from the mean. The distance is m times the distance between the
      mean and the nth percentile of the data. m is given by `invalid_data_removal_multiplier` and n is given by
      `invalid_data_removal_percentile`.

      For example, with m = 4 and n = 5, the mean = 100, and 5% of the data is below/equal to 90, all data below 100 -
      (4 * 10) = 60 and above 100 + (4 * 10) = 140 is considerd invalid.

      :param breaths: list of detected breath objects
      :param data: data the breaths were detected in
      :param time: time axis belonging to the data
      :param outliers: indices of outlier data points



   .. py:method:: _create_breaths_from_peak_valley_data(time: numpy.ndarray, peak_indices: numpy.ndarray, valley_indices: numpy.ndarray) -> list[eitprocessing.datahandling.breath.Breath]


   .. py:method:: _remove_outlier_data(data: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]


   .. py:method:: _detect_peaks_and_valleys(data: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]


   .. py:method:: _detect_invalid_data(data: numpy.ndarray) -> numpy.ndarray


   .. py:method:: _twosidedfill(data: numpy.ndarray) -> numpy.ndarray
      :staticmethod:


      Forward-fill and backward-fill sequences of np.nan values.

      Any np.nan value following a non-nan-value is set to the preceding value. Then np.nan value preceding a
      non-nan-value is set to the following value. These two rules are repeated until all np.nan values are filled
      out.

      .. rubric:: Example

      foo = np.ndarray([np.nan, 1, np.nan, np.nan, np.nan, 3, np.nan, np.nan])
      bar = _twosidedfill(foo)
      # after first loop: np.ndarray([1, 1, 1, np.nan, 3, 3, 3, np.nan])
      # after second loop: np.ndarray([1, 1, 1, 1, 3, 3, 3, 3])
      assert bar == np.ndarray([1, 1, 1, 1, 3, 3, 3, 3])



